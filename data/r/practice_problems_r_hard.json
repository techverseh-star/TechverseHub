[
    {
        "id": "r-h-1",
        "title": "Longest Increasing Subsequence",
        "difficulty": "Hard",
        "language": "r",
        "description": "Given a numeric vector, return the length of the longest increasing subsequence.",
        "examples": "c(10,9,2,5,3,7,101,18) → 4",
        "solution": "lis <- function(nums) {\n  n <- length(nums)\n  dp <- rep(1, n)\n  for(i in 2:n){\n    for(j in 1:(i-1)){\n      if(nums[i] > nums[j]) dp[i] <- max(dp[i], dp[j] + 1)\n    }\n  }\n  max(dp)\n}\nprint(lis(c(10,9,2,5,3,7,101,18)))",
        "hints": "Dynamic programming with dp[i]."
    },
    {
        "id": "r-h-2",
        "title": "Word Break Problem",
        "difficulty": "Hard",
        "language": "r",
        "description": "Check if a string can be segmented into dictionary words.",
        "examples": "\"leetcode\", c(\"leet\",\"code\") → TRUE",
        "solution": "wordBreak <- function(s, dict) {\n  n <- nchar(s)\n  dp <- rep(FALSE, n+1)\n  dp[1] <- TRUE\n  for(i in 2:(n+1)){\n    for(j in 1:(i-1)){\n      if(dp[j] && substr(s, j, i-1) %in% dict){ dp[i] <- TRUE; break }\n    }\n  }\n  dp[n+1]\n}\nprint(wordBreak(\"leetcode\", c(\"leet\",\"code\")))",
        "hints": "Use DP over substrings."
    },
    {
        "id": "r-h-3",
        "title": "Group Anagrams",
        "difficulty": "Hard",
        "language": "r",
        "description": "Group words that are anagrams.",
        "examples": "c(\"eat\",\"tea\",\"ate\")",
        "solution": "groupAnagrams <- function(words){\n  key <- sapply(words, function(w) paste(sort(strsplit(w, \"\")[[1]]), collapse=\"\"))\n  split(words, key)\n}\nprint(groupAnagrams(c(\"eat\",\"tea\",\"ate\")))",
        "hints": "Sort characters to form keys."
    },
    {
        "id": "r-h-4",
        "title": "Merge Overlapping Intervals",
        "difficulty": "Hard",
        "language": "r",
        "description": "Merge overlapping numeric intervals.",
        "examples": "matrix(c(1,3,2,6,8,10), ncol=2, byrow=TRUE)",
        "solution": "mergeIntervals <- function(intervals){\n  intervals <- intervals[order(intervals[,1]),]\n  res <- list(intervals[1,])\n  for(i in 2:nrow(intervals)){\n    last <- res[[length(res)]]\n    if(intervals[i,1] <= last[2]){\n      last[2] <- max(last[2], intervals[i,2])\n      res[[length(res)]] <- last\n    } else res[[length(res)+1]] <- intervals[i,]\n  }\n  do.call(rbind, res)\n}\nprint(mergeIntervals(matrix(c(1,3,2,6,8,10), ncol=2, byrow=TRUE)))",
        "hints": "Sort and merge step-by-step."
    },
    {
        "id": "r-h-5",
        "title": "Top K Frequent Elements",
        "difficulty": "Hard",
        "language": "r",
        "description": "Return k most frequent elements from vector.",
        "examples": "c(1,1,1,2,2,3), k=2 → 1,2",
        "solution": "topK <- function(v, k){\n  freq <- sort(table(v), decreasing=TRUE)\n  as.numeric(names(freq)[1:k])\n}\nprint(topK(c(1,1,1,2,2,3),2))",
        "hints": "Use table() and sort()."
    },
    {
        "id": "r-h-6",
        "title": "Sliding Window Maximum Sum",
        "difficulty": "Hard",
        "language": "r",
        "description": "Find maximum sum of subarray of size k.",
        "examples": "c(2,1,5,1,3,2), k=3 → 9",
        "solution": "maxSum <- function(v,k){\n  cur <- sum(v[1:k])\n  best <- cur\n  for(i in (k+1):length(v)){\n    cur <- cur + v[i] - v[i-k]\n    best <- max(best, cur)\n  }\n  best\n}\nprint(maxSum(c(2,1,5,1,3,2),3))",
        "hints": "Use sliding window."
    },
    {
        "id": "r-h-7",
        "title": "Detect Cycle in Graph",
        "difficulty": "Hard",
        "language": "r",
        "description": "Detect cycle in a directed graph using DFS.",
        "examples": "edges list",
        "solution": "detectCycle <- function(graph){\n  visited <- list(); rec <- list()\n  dfs <- function(v){\n    visited[[v]] <<- TRUE; rec[[v]] <<- TRUE\n    for(n in graph[[v]]){\n      if(is.null(visited[[n]]) && dfs(n)) return(TRUE)\n      else if(!is.null(rec[[n]])) return(TRUE)\n    }\n    rec[[v]] <<- NULL; FALSE\n  }\n  for(v in names(graph)){\n    if(is.null(visited[[v]]) && dfs(v)) return(TRUE)\n  }\n  FALSE\n}",
        "hints": "DFS recursion stack."
    },
    {
        "id": "r-h-8",
        "title": "Binary Search",
        "difficulty": "Hard",
        "language": "r",
        "description": "Implement binary search for sorted vector.",
        "examples": "c(1,3,5,7), target=5 → TRUE",
        "solution": "binSearch <- function(arr, t){\n  l <- 1; r <- length(arr)\n  while(l <= r){\n    m <- floor((l+r)/2)\n    if(arr[m] == t) return(TRUE)\n    if(arr[m] < t) l <- m+1 else r <- m-1\n  }\n  FALSE\n}\nprint(binSearch(c(1,3,5,7),5))",
        "hints": "Classic binary search."
    },
    {
        "id": "r-h-9",
        "title": "Longest Common Prefix",
        "difficulty": "Hard",
        "language": "r",
        "description": "Find longest common prefix among strings.",
        "examples": "c(\"flower\",\"flow\",\"flight\") → \"fl\"",
        "solution": "lcp <- function(strs){\n  p <- strs[1]\n  for(s in strs[-1]){\n    while(!startsWith(s, p)) p <- substr(p,1,nchar(p)-1)\n  }\n  p\n}\nprint(lcp(c(\"flower\",\"flow\",\"flight\")))",
        "hints": "Reduce prefix gradually."
    },
    {
        "id": "r-h-10",
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Hard",
        "language": "r",
        "description": "Evaluate expression in Reverse Polish Notation.",
        "examples": "c(\"2\",\"1\",\"+\",\"3\",\"*\") → 9",
        "solution": "evalRPN <- function(tokens){\n  st <- c()\n  for(t in tokens){\n    if(t %in% c(\"+\",\"-\",\"*\",\"/\")){\n      b <- tail(st,1); a <- tail(st,2)[1]\n      st <- head(st, -2)\n      st <- c(st, switch(t, '+'=a+b, '-'=a-b, '*'=a*b, '/'=a/b))\n    } else st <- c(st, as.numeric(t))\n  }\n  tail(st,1)\n}\nprint(evalRPN(c(\"2\",\"1\",\"+\",\"3\",\"*\")))",
        "hints": "Use stack vector."
    }
]