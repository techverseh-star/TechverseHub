[
    {
        "id": "py-e-1",
        "title": "Two Sum",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. Assume exactly one solution exists and you may not use the same element twice. Return indices in any order.",
        "constraints": "2 <= nums.length <= 10^4, -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9",
        "examples": "Example 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]",
        "solution": "def two_sum(nums, target):\n    lookup = {}\n    for i, n in enumerate(nums):\n        comp = target - n\n        if comp in lookup:\n            return [lookup[comp], i]\n        lookup[n] = i\n    return []",
        "hints": "Use a hash map (dictionary) to store value -> index for O(n) time and O(n) extra space."
    },
    {
        "id": "py-e-2",
        "title": "Reverse String",
        "difficulty": "Easy",
        "language": "python",
        "description": "Write a function that reverses a list of characters in-place. Do not allocate extra space for another array — you must do this by modifying the input array in-place with O(1) extra memory.",
        "constraints": "1 <= len(s) <= 10^5; s contains printable characters.",
        "examples": "Input: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']",
        "solution": "def reverse_string(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s",
        "hints": "Use two-pointer technique or built-in reverse slicing if allowed (but that uses extra memory)."
    },
    {
        "id": "py-e-3",
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase.",
        "constraints": "1 <= s.length, t.length <= 5*10^4; s and t consist of lowercase English letters.",
        "examples": "Input: s = 'anagram', t = 'nagaram'\nOutput: true\n\nInput: s = 'rat', t = 'car'\nOutput: false",
        "solution": "from collections import Counter\n\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return Counter(s) == Counter(t)",
        "hints": "Count characters using dict/Counter or sort both strings and compare (O(n log n))."
    },
    {
        "id": "py-e-4",
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
        "constraints": "1 <= nums.length <= 10^5; -10^9 <= nums[i] <= 10^9",
        "examples": "Input: nums = [1,2,3,1]\nOutput: true\n\nInput: nums = [1,2,3,4]\nOutput: false",
        "solution": "def contains_duplicate(nums):\n    seen = set()\n    for n in nums:\n        if n in seen:\n            return True\n        seen.add(n)\n    return False",
        "hints": "Use a set to track seen values. If memory is tight, sort and check neighbors (O(n log n))."
    },
    {
        "id": "py-e-5",
        "title": "Maximum Subarray",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Use Kadane's algorithm for O(n) time.",
        "constraints": "1 <= nums.length <= 10^5; -10^4 <= nums[i] <= 10^4",
        "examples": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.",
        "solution": "def max_subarray(nums):\n    max_sum = current = nums[0]\n    for n in nums[1:]:\n        current = max(n, current + n)\n        max_sum = max(max_sum, current)\n    return max_sum",
        "hints": "Keep track of current subarray sum and maximum so far; reset current when it becomes negative."
    },
    {
        "id": "py-e-6",
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "language": "python",
        "description": "Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.",
        "constraints": "The number of nodes in both lists is in the range [0, 50]. -100 <= Node.val <= 100",
        "examples": "Input: l1 = [1,2,4], l2 = [1,3,4]\nOutput: [1,1,2,3,4,4]",
        "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_two_lists(l1, l2):\n    dummy = ListNode(0)\n    tail = dummy\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next, l1 = l1, l1.next\n        else:\n            tail.next, l2 = l2, l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next",
        "hints": "Use a dummy head to simplify edge cases; iterate while both lists remain."
    },
    {
        "id": "py-e-7",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given an array prices where prices[i] is the price of a given stock on the ith day, return the maximum profit you can achieve. You may complete at most one transaction (buy one and sell one share).",
        "constraints": "1 <= prices.length <= 10^5; 0 <= prices[i] <= 10^4",
        "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price=1) and sell on day 5 (price=6), profit = 6-1 = 5.",
        "solution": "def max_profit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for p in prices:\n        if p < min_price:\n            min_price = p\n        else:\n            max_profit = max(max_profit, p - min_price)\n    return max_profit",
        "hints": "Track minimum price so far and compute profit if sold today; update maximum."
    },
    {
        "id": "py-e-8",
        "title": "Single Number",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. Implement with O(n) time and O(1) extra space.",
        "constraints": "1 <= nums.length <= 3 * 10^4; -3 * 10^4 <= nums[i] <= 3 * 10^4",
        "examples": "Input: nums = [2,2,1]\nOutput: 1",
        "solution": "def single_number(nums):\n    res = 0\n    for n in nums:\n        res ^= n\n    return res",
        "hints": "Use XOR: x ^ x = 0 and x ^ 0 = x; XOR all numbers to get the unique one."
    },
    {
        "id": "py-e-9",
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays. You may return the result in any order.",
        "constraints": "1 <= nums1.length, nums2.length <= 10^3; 0 <= nums1[i], nums2[i] <= 10^3",
        "examples": "Input: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]",
        "solution": "from collections import Counter\n\ndef intersect(nums1, nums2):\n    c1 = Counter(nums1)\n    res = []\n    for n in nums2:\n        if c1[n] > 0:\n            res.append(n)\n            c1[n] -= 1\n    return res",
        "hints": "Count elements of the smaller array to save memory; then iterate over the other array."
    },
    {
        "id": "py-e-10",
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "language": "python",
        "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed in the correct order.",
        "constraints": "1 <= s.length <= 10^4",
        "examples": "Input: s = '()'\nOutput: true\n\nInput: s = '([)]'\nOutput: false",
        "solution": "def is_valid(s):\n    stack = []\n    pairs = {')':'(', ']':'[', '}':'{'}\n    for ch in s:\n        if ch in pairs:\n            if not stack or stack.pop() != pairs[ch]:\n                return False\n        else:\n            stack.append(ch)\n    return not stack",
        "hints": "Use a stack and mapping of closing->opening brackets. Early-return on mismatch."
    },
    {
        "id": "py-m-1",
        "title": "Add Two Numbers (Linked List)",
        "difficulty": "Medium",
        "language": "python",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
        "constraints": "The number of nodes in each linked list is in the range [1, 100]; 0 <= Node.val <= 9",
        "examples": "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
        "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef add_two_numbers(l1, l2):\n    carry = 0\n    dummy = ListNode(0)\n    cur = dummy\n    while l1 or l2 or carry:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        s = v1 + v2 + carry\n        carry = s // 10\n        cur.next = ListNode(s % 10)\n        cur = cur.next\n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    return dummy.next",
        "hints": "Iterate until both lists exhausted and no carry remains; use a dummy head to build result."
    },
    {
        "id": "py-m-2",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given a string s, find the length of the longest substring without repeating characters. Sliding window with character index map yields O(n) time.",
        "constraints": "0 <= s.length <= 5*10^4",
        "examples": "Input: s = 'abcabcbb'\nOutput: 3\nExplanation: 'abc' is the longest substring without repeating characters.",
        "solution": "def length_of_longest_substring(s):\n    last_index = {}\n    start = 0\n    maxlen = 0\n    for i, ch in enumerate(s):\n        if ch in last_index and last_index[ch] >= start:\n            start = last_index[ch] + 1\n        last_index[ch] = i\n        maxlen = max(maxlen, i - start + 1)\n    return maxlen",
        "hints": "Use sliding window and map char to its last seen index; move left pointer when you see a repeat inside window."
    },
    {
        "id": "py-m-3",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "language": "python",
        "description": "Suppose an array sorted in ascending order is rotated at some pivot. Given target, return its index if present, otherwise -1. Use modified binary search to achieve O(log n).",
        "constraints": "1 <= nums.length <= 10^4; -10^4 <= nums[i] <= 10^4; All values are unique.",
        "examples": "Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4",
        "solution": "def search_rotated(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[l] <= nums[mid]:  # left sorted\n            if nums[l] <= target < nums[mid]:\n                r = mid - 1\n            else:\n                l = mid + 1\n        else:  # right sorted\n            if nums[mid] < target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n    return -1",
        "hints": "Determine which half is sorted and then decide where the target can lie."
    },
    {
        "id": "py-m-4",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given n non-negative integers representing heights where the width between each pair is 1, find two lines that together with x-axis form a container, which contains the most water. Two-pointer technique reduces complexity to O(n).",
        "constraints": "2 <= n <= 10^5; 0 <= height[i] <= 10^4",
        "examples": "Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49",
        "solution": "def max_area(height):\n    l, r = 0, len(height)-1\n    max_area = 0\n    while l < r:\n        area = min(height[l], height[r]) * (r - l)\n        max_area = max(max_area, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return max_area",
        "hints": "Move the pointer at the shorter line inward — only this can increase the area."
    },
    {
        "id": "py-m-5",
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "language": "python",
        "description": "Find the kth largest element in an unsorted array. Use heap or Quickselect (average O(n)).",
        "constraints": "1 <= k <= nums.length <= 10^5; -10^4 <= nums[i] <= 10^4",
        "examples": "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
        "solution": "import heapq\n\ndef find_kth_largest(nums, k):\n    # maintain min-heap of size k\n    heap = nums[:k]\n    heapq.heapify(heap)\n    for num in nums[k:]:\n        if num > heap[0]:\n            heapq.heapreplace(heap, num)\n    return heap[0]",
        "hints": "Use a min-heap of size k to drop smaller elements; or Quickselect for average O(n)."
    },
    {
        "id": "py-m-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given a non-empty array of integers, return the k most frequent elements. Use a heap or bucket sort by frequency.",
        "constraints": "1 <= nums.length <= 10^5; k is in [1, number of unique elements]",
        "examples": "Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]",
        "solution": "from collections import Counter\nimport heapq\n\ndef top_k_frequent(nums, k):\n    count = Counter(nums)\n    return [item for item, _ in count.most_common(k)]",
        "hints": "Counter.most_common is a quick option; otherwise use buckets or heap selection."
    },
    {
        "id": "py-m-7",
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given an array nums of n integers where n > 1, return an array output such that output[i] is the product of all elements except nums[i]. Solve without division and in O(n) time.",
        "constraints": "2 <= nums.length <= 10^5; -30 <= nums[i] <= 30",
        "examples": "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
        "solution": "def product_except_self(nums):\n    n = len(nums)\n    out = [1]*n\n    prefix = 1\n    for i in range(n):\n        out[i] = prefix\n        prefix *= nums[i]\n    suffix = 1\n    for i in range(n-1,-1,-1):\n        out[i] *= suffix\n        suffix *= nums[i]\n    return out",
        "hints": "Compute prefix products in one pass and suffix products in a second pass to avoid division."
    },
    {
        "id": "py-m-8",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. Use DFS/BFS to mark visited land.",
        "constraints": "m,n <= 300",
        "examples": "Input: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3",
        "solution": "def num_islands(grid):\n    if not grid: return 0\n    m, n = len(grid), len(grid[0])\n    def dfs(i,j):\n        if i<0 or j<0 or i>=m or j>=n or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1)\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i,j)\n    return count",
        "hints": "Mark visited cells in-place by changing '1' to '0' (or keep a visited set). Use DFS or BFS."
    },
    {
        "id": "py-m-9",
        "title": "Coin Change",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given coins of different denominations and a total amount, compute the fewest number of coins needed to make up that amount. Use dynamic programming (unbounded knapsack variant).",
        "constraints": "1 <= coins.length <= 12; 0 <= amount <= 10^4",
        "examples": "Input: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1",
        "solution": "def coin_change(coins, amount):\n    dp = [float('inf')] * (amount+1)\n    dp[0] = 0\n    for coin in coins:\n        for x in range(coin, amount+1):\n            dp[x] = min(dp[x], dp[x-coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1",
        "hints": "1D DP: dp[x] = min coins to make amount x; iterate coins and amounts to allow reuse."
    },
    {
        "id": "py-m-10",
        "title": "Word Break",
        "difficulty": "Medium",
        "language": "python",
        "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Use DP or BFS.",
        "constraints": "1 <= s.length <= 300; 1 <= wordDict.length <= 1000; word length <= 20",
        "examples": "Input: s = 'leetcode', wordDict = ['leet','code']\nOutput: true",
        "solution": "def word_break(s, wordDict):\n    n = len(s)\n    dp = [False] * (n+1)\n    dp[0] = True\n    wordset = set(wordDict)\n    for i in range(1, n+1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordset:\n                dp[i] = True\n                break\n    return dp[n]",
        "hints": "dp[i] = whether prefix length i is segmentable; check previous valid cuts and dictionary membership."
    },
    {
        "id": "py-h-1",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "language": "python",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Use binary search on partitions.",
        "constraints": "0 <= m, n <= 10^6; -10^9 <= nums[i] <= 10^9",
        "examples": "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.0\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.5",
        "solution": "def find_median_sorted_arrays(nums1, nums2):\n    A, B = nums1, nums2\n    m, n = len(A), len(B)\n    if m > n:\n        A, B, m, n = B, A, n, m\n    imin, imax, half = 0, m, (m + n + 1) // 2\n    while imin <= imax:\n        i = (imin + imax) // 2\n        j = half - i\n        if i < m and B[j-1] > A[i]:\n            imin = i + 1\n        elif i > 0 and A[i-1] > B[j]:\n            imax = i - 1\n        else:\n            if i == 0: left_max = B[j-1]\n            elif j == 0: left_max = A[i-1]\n            else: left_max = max(A[i-1], B[j-1])\n            if (m + n) % 2 == 1:\n                return left_max\n            if i == m: right_min = B[j]\n            elif j == n: right_min = A[i]\n            else: right_min = min(A[i], B[j])\n            return (left_max + right_min) / 2.0",
        "hints": "Binary search partition on the smaller array; careful boundary handling."
    },
    {
        "id": "py-h-2",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "language": "python",
        "description": "Implement regular expression matching with support for '.' and '*'. '.' matches any single character. '*' matches zero or more of the preceding element. Full DP solution required for worst-case exponential naive recursion.",
        "constraints": "0 <= s.length, p.length <= 20",
        "examples": "Input: s = 'aab', p = 'c*a*b'\nOutput: true",
        "solution": "def is_match(s, p):\n    m, n = len(s), len(p)\n    dp = [[False]*(n+1) for _ in range(m+1)]\n    dp[0][0] = True\n    for j in range(2, n+1):\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-2]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if p[j-1] == '.' or p[j-1] == s[i-1]:\n                dp[i][j] = dp[i-1][j-1]\n            elif p[j-1] == '*':\n                dp[i][j] = dp[i][j-2]\n                if p[j-2] == '.' or p[j-2] == s[i-1]:\n                    dp[i][j] = dp[i][j] or dp[i-1][j]\n    return dp[m][n]",
        "hints": "Use DP table dp[i][j] meaning s[:i] matches p[:j]; handle '*' as zero or more of previous pattern."
    },
    {
        "id": "py-h-3",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "language": "python",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Use two-pointer technique with O(n) time and O(1) space.",
        "constraints": "0 <= n <= 2*10^4; 0 <= height[i] <= 10^5",
        "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6",
        "solution": "def trap(height):\n    if not height: return 0\n    l, r = 0, len(height)-1\n    left_max = right_max = 0\n    ans = 0\n    while l < r:\n        if height[l] < height[r]:\n            if height[l] >= left_max:\n                left_max = height[l]\n            else:\n                ans += left_max - height[l]\n            l += 1\n        else:\n            if height[r] >= right_max:\n                right_max = height[r]\n            else:\n                ans += right_max - height[r]\n            r -= 1\n    return ans",
        "hints": "Maintain left_max and right_max; move the pointer at the smaller height inward and accumulate trapped water."
    },
    {
        "id": "py-h-4",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "language": "python",
        "description": "Merge k sorted linked lists and return it as one sorted list. Analyze approaches: pairwise merge (O(N log k)) or min-heap over heads (O(N log k)), where N is total nodes.",
        "constraints": "k ranges up to 10^4, total nodes up to 10^5",
        "examples": "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
        "solution": "import heapq\n\nclass Wrapper:\n    def __init__(self, node):\n        self.node = node\n    def __lt__(self, other):\n        return self.node.val < other.node.val\n\n\ndef merge_k_lists(lists):\n    dummy = ListNode(0)\n    tail = dummy\n    heap = []\n    for node in lists:\n        if node:\n            heapq.heappush(heap, Wrapper(node))\n    while heap:\n        smallest = heapq.heappop(heap).node\n        tail.next = smallest\n        tail = tail.next\n        if smallest.next:\n            heapq.heappush(heap, Wrapper(smallest.next))\n    return dummy.next",
        "hints": "Use a min-heap containing the head node of each list; pop smallest and push its next until heap empty."
    },
    {
        "id": "py-h-5",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "python",
        "description": "Given strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included. If there is no such window, return an empty string.",
        "constraints": "1 <= m, n <= 10^5",
        "examples": "Input: s = 'ADOBECODEBANC', t = 'ABC'\nOutput: 'BANC'",
        "solution": "from collections import Counter\n\ndef min_window(s, t):\n    if not t or not s: return ''\n    need = Counter(t)\n    missing = len(t)\n    left = start = end = 0\n    for right, ch in enumerate(s, 1):\n        if need[ch] > 0:\n            missing -= 1\n        need[ch] -= 1\n        while missing == 0:\n            if not end or right - left < end - start:\n                start, end = left, right\n            need[s[left]] += 1\n            if need[s[left]] > 0:\n                missing += 1\n            left += 1\n    return s[start:end]",
        "hints": "Use sliding window with counts: expand until window valid, then contract to find minimum; track missing characters."
    },
    {
        "id": "py-h-6",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "language": "python",
        "description": "Given beginWord, endWord and a dictionary wordList, return the length of shortest transformation sequence from beginWord to endWord such that only one letter can be changed at a time and each transformed word must exist in wordList. Use BFS on the implicit graph where edges connect words with one-letter difference.",
        "constraints": "1 <= wordList.length <= 5000; word length <= 10",
        "examples": "Input: beginWord = 'hit', endWord = 'cog', wordList = ['hot','dot','dog','lot','log','cog']\nOutput: 5\nExplanation: 'hit' -> 'hot' -> 'dot' -> 'dog' -> 'cog'.",
        "solution": "from collections import deque, defaultdict\n\ndef ladder_length(begin, end, wordList):\n    L = len(begin)\n    all_combo = defaultdict(list)\n    for word in wordList:\n        for i in range(L):\n            all_combo[word[:i] + '*' + word[i+1:]].append(word)\n    queue = deque([(begin,1)])\n    visited = {begin: True}\n    while queue:\n        word, level = queue.popleft()\n        for i in range(L):\n            pattern = word[:i] + '*' + word[i+1:]\n            for w in all_combo.get(pattern, []):\n                if w == end:\n                    return level + 1\n                if w not in visited:\n                    visited[w] = True\n                    queue.append((w, level+1))\n            all_combo[pattern] = []\n    return 0",
        "hints": "Precompute generic transformations (with '*') to find neighbors quickly; BFS for shortest path."
    },
    {
        "id": "py-h-7",
        "title": "N-Queens",
        "difficulty": "Hard",
        "language": "python",
        "description": "The n-queens puzzle: place n queens on an n×n chessboard so that no two queens attack each other. Return all distinct solutions. Use backtracking with pruning (columns, positive diagonals, negative diagonals sets).",
        "constraints": "1 <= n <= 9",
        "examples": "Input: n = 4\nOutput: [\n [\".Q..\",\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n [\"..Q.\",\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]",
        "solution": "def solve_n_queens(n):\n    cols = set()\n    pos_diag = set()\n    neg_diag = set()\n    board = [['.']*n for _ in range(n)]\n    res = []\n    def backtrack(r):\n        if r == n:\n            res.append([''.join(row) for row in board])\n            return\n        for c in range(n):\n            if c in cols or (r+c) in pos_diag or (r-c) in neg_diag:\n                continue\n            cols.add(c); pos_diag.add(r+c); neg_diag.add(r-c)\n            board[r][c] = 'Q'\n            backtrack(r+1)\n            cols.remove(c); pos_diag.remove(r+c); neg_diag.remove(r-c)\n            board[r][c] = '.'\n    backtrack(0)\n    return res",
        "hints": "Track occupied columns and diagonals to prune available positions quickly; backtrack by row."
    },
    {
        "id": "py-h-8",
        "title": "Longest Consecutive Sequence",
        "difficulty": "Hard",
        "language": "python",
        "description": "Given an unsorted array of integers, return the length of the longest consecutive elements sequence. Solve in O(n) using a hash set to start sequences only at sequence starts.",
        "constraints": "0 <= nums.length <= 10^5",
        "examples": "Input: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1,2,3,4].",
        "solution": "def longest_consecutive(nums):\n    nums_set = set(nums)\n    longest = 0\n    for n in nums_set:\n        if n-1 not in nums_set:\n            length = 1\n            while n+length in nums_set:\n                length += 1\n            longest = max(longest, length)\n    return longest",
        "hints": "Only start counting when number-1 is not in set to ensure O(n) overall."
    },
    {
        "id": "py-h-9",
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "language": "python",
        "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization converts a tree to a string and deserialization reconstructs the tree. Use BFS or preorder with null markers.",
        "constraints": "The number of nodes is in the range [0, 10^4].",
        "examples": "Input: root = [1,2,3,null,null,4,5]\nOutput: same tree after serialize-deserialize cycle",
        "solution": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef serialize(root):\n    if not root: return '#'\n    res = []\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if node:\n            res.append(str(node.val))\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            res.append('#')\n    return ','.join(res)\n\ndef deserialize(data):\n    if data == '#': return None\n    vals = data.split(',')\n    root = TreeNode(int(vals[0]))\n    queue = deque([root])\n    i = 1\n    while queue:\n        node = queue.popleft()\n        if vals[i] != '#':\n            node.left = TreeNode(int(vals[i]))\n            queue.append(node.left)\n        i += 1\n        if vals[i] != '#':\n            node.right = TreeNode(int(vals[i]))\n            queue.append(node.right)\n        i += 1\n    return root",
        "hints": "Use a delimiter and a null marker; BFS ensures fixed ordering of children for consistent reconstruction."
    },
    {
        "id": "py-h-10",
        "title": "Minimum Cost to Connect All Points (Prim/Kruskal)",
        "difficulty": "Hard",
        "language": "python",
        "description": "Given n points on a 2D plane, return minimum cost to connect all points where cost between two points is Manhattan distance. Find a minimum spanning tree using Prim's (O(n^2) naive) or Kruskal with edges (O(E log E)).",
        "constraints": "1 <= n <= 1000",
        "examples": "Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20",
        "solution": "import heapq\n\ndef min_cost_connect_points(points):\n    n = len(points)\n    visited = [False]*n\n    def dist(i,j):\n        return abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n    # Prim's algorithm\n    pq = [(0,0)]\n    res = 0\n    cnt = 0\n    while pq and cnt < n:\n        cost,u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        res += cost\n        cnt += 1\n        for v in range(n):\n            if not visited[v]:\n                heapq.heappush(pq, (dist(u,v), v))\n    return res",
        "hints": "Use Prim's with a min-heap storing best edge to unvisited nodes; O(n^2 log n) naive but acceptable for n<=1000."
    }
]