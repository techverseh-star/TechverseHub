{
  "id": "py-14",
  "title": "Iterators, Generators & Decorators",
  "content": "Iterators implement __iter__ and __next__. Generators use yield for lazy sequences. Decorators (@decorator) wrap functions to modify behavior (e.g., logging, timing).",
  "codeExample": "def counter(n):\n    for i in range(n):\n        yield i\n\nfor x in counter(3):\n    print(x)\n\n# simple decorator\nfrom functools import wraps\n\ndef debug(f):\n    @wraps(f)\n    def wrapper(*a,**k):\n        print('call', f.__name__)\n        return f(*a,**k)\n    return wrapper\n\n@debug\ndef add(a,b):\n    return a+b\n\nprint(add(2,3))",
  "trystarter": "def gen_even(n):\n    for i in range(n):\n        if i%2==0:\n            yield i\n\nprint(list(gen_even(10)))",
  "language": "python"
}