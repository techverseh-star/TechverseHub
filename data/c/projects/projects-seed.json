[
  {
    "id": "c-1",
    "title": "Student Record System",
    "language": "c",
    "difficulty": "Beginner",
    "duration": "3-4 hours",
    "description": "Build a file-based student database using structs.",
    "overview": "Create a student record system with file persistence.",
    "concepts": [
      "Structs",
      "File I/O",
      "Arrays",
      "Pointers"
    ],
    "steps": [
      {
        "title": "Step 1 struct",
        "description": "Create Student struct."
      },
      {
        "title": "Step 2/display",
        "description": "Implement CRUD operations."
      },
      {
        "title": "Step 3 storage",
        "description": "Save to binary file."
      }
    ],
    "starterCode": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float grade;\n} Student;\n\nStudent students[100];\nint count = 0;\n\nvoid addStudent(int id, const char* name, float grade) {\n    // TODO student to array\n}\n\nvoid displayAll() {\n    // TODO all students\n}\n\nint main() {\n    addStudent(1, \"Alice\", 85.5);\n    addStudent(2, \"Bob\", 90.0);\n    displayAll();\n    return 0;\n}\n",
    "solution": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[50];\n    float grade;\n} Student;\n\nStudent students[100];\nint count = 0;\n\nvoid addStudent(int id, const char* name, float grade) {\n    students[count].id = id;\n    strcpy(students[count].name, name);\n    students[count].grade = grade;\n    count++;\n}\n\nvoid displayAll() {\n    printf(\"\\n--- Students ---\\n\");\n    for (int i = 0; i < count; i++) {\n        printf(\"ID: %d, Name: %s, Grade: %.1f\\n\",\n            students[i].id, students[i].name, students[i].grade);\n    }\n}\n\nint main() {\n    addStudent(1, \"Alice\", 85.5);\n    addStudent(2, \"Bob\", 90.0);\n    displayAll();\n    return 0;\n}\n"
  },
  {
    "id": "c-2",
    "title": "Dynamic Array Library",
    "language": "c",
    "difficulty": "Intermediate",
    "duration": "5-6 hours",
    "description": "Implement a resizable array with memory management.",
    "overview": "Build a dynamic array that grows automatically.",
    "concepts": [
      "Pointers",
      "malloc/free",
      "Memory",
      "Data Structures"
    ],
    "steps": [
      {
        "title": "Step 1",
        "description": "Define dynamic array struct."
      },
      {
        "title": "Step 2",
        "description": "Implement automatic resizing."
      },
      {
        "title": "Step 3",
        "description": "Add push, pop, get functions."
      }
    ],
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int* data;\n    int size;\n    int capacity;\n} DynArray;\n\nDynArray* createArray(int capacity) {\n    // TODO and return array\n    return NULL;\n}\n\nvoid push(DynArray* arr, int value) {\n    // TODO element, resize if needed\n}\n\nvoid freeArray(DynArray* arr) {\n    // TODO memory\n}\n\nint main() {\n    DynArray* arr = createArray(2);\n    push(arr, 10);\n    push(arr, 20);\n    push(arr, 30);\n    printf(\"Size: %d\\n\", arr->size);\n    freeArray(arr);\n    return 0;\n}\n",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int* data;\n    int size;\n    int capacity;\n} DynArray;\n\nDynArray* createArray(int capacity) {\n    DynArray* arr = malloc(sizeof(DynArray));\n    arr->data = malloc(capacity * sizeof(int));\n    arr->size = 0;\n    arr->capacity = capacity;\n    return arr;\n}\n\nvoid push(DynArray* arr, int value) {\n    if (arr->size >= arr->capacity) {\n        arr->capacity *= 2;\n        arr->data = realloc(arr->data, arr->capacity * sizeof(int));\n    }\n    arr->data[arr->size++] = value;\n}\n\nvoid freeArray(DynArray* arr) {\n    free(arr->data);\n    free(arr);\n}\n\nint main() {\n    DynArray* arr = createArray(2);\n    for (int i = 0; i < 10; i++) push(arr, i * 10);\n    printf(\"Size: %d, Capacity: %d\\n\", arr->size, arr->capacity);\n    freeArray(arr);\n    return 0;\n}\n"
  },
  {
    "id": "c-3",
    "title": "Mini Shell",
    "language": "c",
    "difficulty": "Advanced",
    "duration": "10-15 hours",
    "description": "Build a Unix-like command shell.",
    "overview": "Create a basic shell that can execute commands.",
    "concepts": [
      "fork/exec",
      "Pipes",
      "System calls",
      "Signal handling"
    ],
    "steps": [
      {
        "title": "Step 1 parsing",
        "description": "Parse user input."
      },
      {
        "title": "Step 2 commands",
        "description": "Fork and exec."
      },
      {
        "title": "Step 3-in commands",
        "description": "Add cd, exit, etc."
      }
    ],
    "starterCode": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid parseCommand(char* input, char** args) {\n    // TODO input into args\n}\n\nvoid executeCommand(char** args) {\n    // TODO and execute\n}\n\nint main() {\n    char input[256];\n    char* args[10];\n    \n    while (1) {\n        printf(\"myshell> \");\n        fgets(input, 256, stdin);\n        input[strlen(input)-1] = '\\0';\n        \n        if (strcmp(input, \"exit\") == 0) break;\n        \n        // TODO and execute\n    }\n    return 0;\n}\n",
    "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nvoid parseCommand(char* input, char** args) {\n    int i = 0;\n    args[i] = strtok(input, \" \");\n    while (args[i] != NULL) {\n        args[++i] = strtok(NULL, \" \");\n    }\n}\n\nvoid executeCommand(char** args) {\n    pid_t pid = fork();\n    if (pid == 0) {\n        execvp(args[0], args);\n        perror(\"exec failed\");\n        exit(1);\n    } else {\n        wait(NULL);\n    }\n}\n\nint main() {\n    char input[256];\n    char* args[10];\n    \n    while (1) {\n        printf(\"myshell> \");\n        if (!fgets(input, 256, stdin)) break;\n        input[strlen(input)-1] = '\\0';\n        \n        if (strcmp(input, \"exit\") == 0) break;\n        if (strlen(input) == 0) continue;\n        \n        parseCommand(input, args);\n        executeCommand(args);\n    }\n    return 0;\n}\n"
  }
]