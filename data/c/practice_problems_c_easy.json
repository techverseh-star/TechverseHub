[
    {
        "id": "c-e-1",
        "title": "Two Sum",
        "difficulty": "Easy",
        "language": "c",
        "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add to target. Use a hash map technique (implemented manually via arrays).",
        "examples": "Input: nums=[2,7,11,15], target=9\nOutput: [0,1]",
        "solution": "int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    static int map[2048];\n    for(int i=0;i<2048;i++) map[i] = -1;\n    for(int i=0;i<numsSize;i++){\n        int diff = target - nums[i];\n        int idx = (diff & 2047);\n        if (map[idx] != -1) {\n            int* res = malloc(2 * sizeof(int));\n            res[0] = map[idx];\n            res[1] = i;\n            *returnSize = 2;\n            return res;\n        }\n        map[nums[i] & 2047] = i;\n    }\n    *returnSize = 0;\n    return NULL;\n}",
        "hints": "Use manual hash map with modulo masking."
    },
    {
        "id": "c-e-2",
        "title": "Reverse String",
        "difficulty": "Easy",
        "language": "c",
        "description": "Reverse an array of characters in place using two-pointer swapping.",
        "examples": "Input: ['h','e','l','l','o'] → ['o','l','l','e','h']",
        "solution": "void reverseString(char* s, int sSize) {\n    int l=0, r=sSize-1;\n    while(l<r){\n        char temp=s[l];\n        s[l]=s[r];\n        s[r]=temp;\n        l++; r--;\n    }\n}",
        "hints": "Use XOR or temp variable for swapping."
    },
    {
        "id": "c-e-3",
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "language": "c",
        "description": "Check if two strings are anagrams by counting character frequencies.",
        "examples": "Input: s='anagram', t='nagaram' → true",
        "solution": "bool isAnagram(char* s, char* t) {\n    int count[26]={0};\n    int i=0;\n    while(s[i] && t[i]){\n        count[s[i]-'a']++;\n        count[t[i]-'a']--;\n        i++;\n    }\n    if(s[i] || t[i]) return false;\n    for(int j=0;j<26;j++) if(count[j]!=0) return false;\n    return true;\n}",
        "hints": "If lengths differ, return false early."
    },
    {
        "id": "c-e-4",
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "language": "c",
        "description": "Return true if any integer appears more than once. Use a hash set.",
        "examples": "Input: [1,2,3,1] → true",
        "solution": "bool containsDuplicate(int* nums, int numsSize) {\n    int seen[4096];\n    for(int i=0;i<4096;i++) seen[i] = 0;\n    for(int i=0;i<numsSize;i++){\n        int idx = (nums[i] & 4095);\n        if (seen[idx]) return true;\n        seen[idx] = 1;\n    }\n    return false;\n}",
        "hints": "Use masking to simulate hash set."
    },
    {
        "id": "c-e-5",
        "title": "Maximum Subarray",
        "difficulty": "Easy",
        "language": "c",
        "description": "Find contiguous subarray with maximum sum using Kadane's algorithm.",
        "examples": "Input: [-2,1,-3,4,-1,2,1,-5,4] → 6",
        "solution": "int maxSubArray(int* nums, int numsSize) {\n    int maxSum = nums[0];\n    int cur = nums[0];\n    for(int i=1;i<numsSize;i++){\n        cur = (cur + nums[i] > nums[i]) ? cur + nums[i] : nums[i];\n        if(cur > maxSum) maxSum = cur;\n    }\n    return maxSum;\n}",
        "hints": "Reset when current sum becomes negative."
    },
    {
        "id": "c-e-6",
        "title": "Move Zeroes",
        "difficulty": "Easy",
        "language": "c",
        "description": "Move all zeroes to the end while maintaining relative order.",
        "examples": "Input: [0,1,0,3,12] → [1,3,12,0,0]",
        "solution": "void moveZeroes(int* nums, int numsSize) {\n    int pos=0;\n    for(int i=0;i<numsSize;i++) if(nums[i]!=0) nums[pos++] = nums[i];\n    while(pos < numsSize) nums[pos++] = 0;\n}",
        "hints": "Two-pass solution: compress non-zero elements."
    },
    {
        "id": "c-e-7",
        "title": "Single Number",
        "difficulty": "Easy",
        "language": "c",
        "description": "Find the number that appears once while others appear twice using XOR.",
        "examples": "Input: [2,2,1] → 1",
        "solution": "int singleNumber(int* nums, int numsSize) {\n    int res=0;\n    for(int i=0;i<numsSize;i++) res ^= nums[i];\n    return res;\n}",
        "hints": "XOR cancels duplicates."
    },
    {
        "id": "c-e-8",
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": "Easy",
        "language": "c",
        "description": "Find minimum element using binary search.",
        "examples": "Input: [3,4,5,1,2] → 1",
        "solution": "int findMin(int* nums, int numsSize) {\n    int l=0, r=numsSize-1;\n    while(l<r){\n        int m=(l+r)/2;\n        if(nums[m] > nums[r]) l=m+1;\n        else r=m;\n    }\n    return nums[l];\n}",
        "hints": "Check pivot based on nums[mid] vs nums[right]."
    },
    {
        "id": "c-e-9",
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "language": "c",
        "description": "Check if parentheses are valid using stack simulation.",
        "examples": "Input: \"()[]{}\" → true",
        "solution": "bool isValid(char* s) {\n    char stack[10000]; int top=-1;\n    for(int i=0;s[i];i++){\n        char c=s[i];\n        if(c=='('||c=='['||c=='{') stack[++top]=c;\n        else{\n            if(top<0) return false;\n            char p=stack[top--];\n            if((c==')'&&p!='(')||(c==']'&&p!='[')||(c=='}'&&p!='{')) return false;\n        }\n    }\n    return top==-1;\n}",
        "hints": "Push opening brackets, match with closing."
    },
    {
        "id": "c-e-10",
        "title": "Fibonacci Number",
        "difficulty": "Easy",
        "language": "c",
        "description": "Compute the n-th Fibonacci number using iteration.",
        "examples": "Input: 4 → 3",
        "solution": "int fib(int n) {\n    if(n<2) return n;\n    int a=0,b=1;\n    for(int i=2;i<=n;i++){\n        int t=a+b;\n        a=b;\n        b=t;\n    }\n    return b;\n}",
        "hints": "Avoid recursion due to stack overhead."
    }
]