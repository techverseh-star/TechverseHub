[
    {
        "id": "c-h-1",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "language": "c",
        "description": "You are given k linked-lists sorted in ascending order. Merge all k lists into one sorted list using a min-heap approach.",
        "examples": "Input: [[1,4,5],[1,3,4],[2,6]] → [1,1,2,3,4,4,5,6]",
        "solution": "#define HEAPSIZE 10000\nstruct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\n    struct ListNode* heap[HEAPSIZE]; int hsize=0;\n    #define parent(i) ((i-1)/2)\n    #define left(i) (2*i+1)\n    #define right(i) (2*i+2)\n    void push(struct ListNode* n){ if(!n) return; heap[hsize]=n; int i=hsize++;\n        while(i>0 && heap[i]->val < heap[parent(i)]->val){ struct ListNode* t=heap[i]; heap[i]=heap[parent(i)]; heap[parent(i)]=t; i=parent(i);} }\n    struct ListNode* pop(){ if(hsize==0) return NULL; struct ListNode* top=heap[0]; heap[0]=heap[--hsize]; int i=0;\n        while(1){ int l=left(i), r=right(i), s=i;\n            if(l<hsize && heap[l]->val < heap[s]->val) s=l;\n            if(r<hsize && heap[r]->val < heap[s]->val) s=r;\n            if(s==i) break;\n            struct ListNode* t=heap[i]; heap[i]=heap[s]; heap[s]=t; i=s;\n        }\n        return top; }\n    for(int i=0;i<listsSize;i++) push(lists[i]);\n    struct ListNode dummy; dummy.next=NULL; struct ListNode* cur=&dummy;\n    while(hsize){ struct ListNode* n=pop(); cur->next=n; cur=n; push(n->next); }\n    return dummy.next;\n}",
        "hints": "Use a min-heap storing the head nodes."
    },
    {
        "id": "c-h-2",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "language": "c",
        "description": "Compute trapped rainwater using two-pointer max-boundary logic.",
        "examples": "Input: [0,1,0,2,1,0,1,3,2,1,2,1] → 6",
        "solution": "int trap(int* h, int n){ int l=0,r=n-1, lm=0, rm=0, ans=0;\n    while(l<r){ if(h[l] < h[r]){ if(h[l] >= lm) lm=h[l]; else ans += lm - h[l]; l++; }\n        else { if(h[r] >= rm) rm=h[r]; else ans += rm - h[r]; r--; } }\n    return ans; }",
        "hints": "Move pointer from smaller height inward."
    },
    {
        "id": "c-h-3",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "c",
        "description": "Find the smallest substring that contains all characters of t using sliding window and counts.",
        "examples": "Input: s=\"ADOBECODEBANC\", t=\"ABC\" → \"BANC\"",
        "solution": "char* minWindow(char* s, char* t){ static char out[10000]; out[0]='\\0';\n    int need[128]={0}, have[128]={0}; int required=0;\n    for(int i=0;t[i];i++){ if(!need[(int)t[i]]) required++; need[(int)t[i]]++; }\n    int formed=0, l=0, minLen=100000, start=0;\n    for(int r=0;s[r];r++){\n        have[(int)s[r]]++;\n        if(need[(int)s[r]] && have[(int)s[r]] == need[(int)s[r]]) formed++;\n        while(formed == required){ if(r-l+1 < minLen){ minLen=r-l+1; start=l; }\n            have[(int)s[l]]--; if(need[(int)s[l]] && have[(int)s[l]] < need[(int)s[l]]) formed--; l++; }\n    }\n    if(minLen==100000) return \"\";\n    strncpy(out, s+start, minLen); out[minLen]='\\0'; return out; }",
        "hints": "Expand window → shrink when valid → track best range."
    },
    {
        "id": "c-h-4",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "language": "c",
        "description": "Find the shortest transformation sequence using BFS over wildcard patterns.",
        "examples": "hit → cog in 5 steps",
        "solution": "/* Simplified C BFS (dictionary size < 5000 assumed) */\nint ladderLength(char* begin, char* end, char** words, int n){ int L=strlen(begin);\n    int used[5000]={0}; int q[5000], dist[5000], front=0, back=0;\n    q[back]= -1; dist[back++]=1; // -1 = begin word\n    while(front < back){ int idx=q[front], d=dist[front++]; char* w = (idx==-1?begin:words[idx]);\n        if(idx!=-1 && strcmp(w,end)==0) return d;\n        for(int i=0;i<n;i++) if(!used[i]){\n            int diff=0; for(int j=0;j<L;j++) if(w[j]!=words[i][j] && ++diff>1) break;\n            if(diff==1){ used[i]=1; q[back]=i; dist[back++]=d+1; }\n        }\n    }\n    return 0; }",
        "hints": "Adjacent words differ by exactly one character."
    },
    {
        "id": "c-h-5",
        "title": "N-Queens",
        "difficulty": "Hard",
        "language": "c",
        "description": "Place N queens so none attack each other and return number of solutions.",
        "examples": "n=4 → 2 solutions",
        "solution": "int ans;\nvoid solve(int r, int n, int* col, int* d1, int* d2){ if(r==n){ ans++; return; }\n    for(int c=0;c<n;c++) if(!col[c] && !d1[r+c] && !d2[r-c+n]){\n        col[c]=d1[r+c]=d2[r-c+n]=1;\n        solve(r+1,n,col,d1,d2);\n        col[c]=d1[r+c]=d2[r-c+n]=0;\n    }}\nint totalNQueens(int n){ int col[30]={0}, d1[60]={0}, d2[60]={0}; ans=0; solve(0,n,col,d1,d2); return ans; }",
        "hints": "Use diagonals: r+c and r-c+n."
    },
    {
        "id": "c-h-6",
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "language": "c",
        "description": "Serialize a binary tree into string and deserialize back using queue logic.",
        "examples": "Input: [1,2,3,null,null,4,5]",
        "solution": "char* serialize(struct TreeNode* root){ static char out[20000]; out[0]='\\0';\n    if(!root) return \"#\";\n    struct TreeNode* q[10000]; int front=0,back=0;\n    q[back++]=root;\n    while(front<back){ struct TreeNode* n=q[front++]; if(!n){ strcat(out,\"#, \"); continue; }\n        char buf[32]; sprintf(buf,\"%d, \",n->val); strcat(out,buf);\n        q[back++]=n->left; q[back++]=n->right;\n    }\n    return out; }\nstruct TreeNode* deserialize(char* data){ if(data[0]=='#') return NULL;\n    char* token=strtok(data,\", \"); int vals[10000], cnt=0;\n    while(token){ vals[cnt++]=atoi(token); token=strtok(NULL,\", \"); }\n    struct TreeNode* root=malloc(sizeof(struct TreeNode)); root->val=vals[0]; root->left=root->right=NULL;\n    struct TreeNode* q[10000]; int front=0,back=0; q[back++]=root; int i=1;\n    while(front<back && i<cnt){ struct TreeNode* n=q[front++];\n        if(strcmp(token,\"#\")!=0){ n->left=malloc(sizeof(struct TreeNode)); n->left->val=vals[i++]; n->left->left=n->left->right=NULL; q[back++]=n->left; }\n        if(strcmp(token,\"#\")!=0){ n->right=malloc(sizeof(struct TreeNode)); n->right->val=vals[i++]; n->right->left=n->right->right=NULL; q[back++]=n->right; }\n    }\n    return root; }",
        "hints": "Level-order traversal with '#' markers."
    },
    {
        "id": "c-h-7",
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "language": "c",
        "description": "Use interval DP to compute max coins obtained by optimally bursting balloons.",
        "examples": "Input: [3,1,5,8] → 167",
        "solution": "int maxCoins(int* nums, int n){ int a[510]; for(int i=1;i<=n;i++) a[i]=nums[i-1]; a[0]=a[n+1]=1;\n    int dp[510][510]={0};\n    for(int len=2; len<=n+1; len++){\n        for(int l=0; l+len<=n+1; l++){\n            int r=l+len;\n            for(int k=l+1; k<r; k++){\n                int v=a[l]*a[k]*a[r] + dp[l][k] + dp[k][r];\n                if(v > dp[l][r]) dp[l][r]=v;\n            }\n        }\n    }\n    return dp[0][n+1]; }",
        "hints": "Try each balloon as the last popped."
    },
    {
        "id": "c-h-8",
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "language": "c",
        "description": "Find longest valid parentheses substring using stack of indices.",
        "examples": "Input: \"(()\" → 2",
        "solution": "int longestValidParentheses(char* s){ int stack[10000]; int top=-1; int max=0; stack[++top] = -1;\n    for(int i=0;s[i];i++){\n        if(s[i]=='(') stack[++top]=i;\n        else{\n            top--;\n            if(top<0){ stack[++top]=i; }\n            else{\n                int len = i - stack[top]; if(len>max) max=len;\n            }\n        }\n    }\n    return max; }",
        "hints": "Push -1 to handle base offset."
    },
    {
        "id": "c-h-9",
        "title": "Edit Distance",
        "difficulty": "Hard",
        "language": "c",
        "description": "Compute minimum edit operations (insert, delete, replace) between two strings using DP.",
        "examples": "Input: horse → ros → 3",
        "solution": "int minDistance(char* w1, char* w2){ int n=strlen(w1), m=strlen(w2);\n    int dp[510][510];\n    for(int i=0;i<=n;i++) dp[i][0]=i;\n    for(int j=0;j<=m;j++) dp[0][j]=j;\n    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\n        if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\n        else{\n            int mn=dp[i-1][j]; if(dp[i][j-1]<mn) mn=dp[i][j-1]; if(dp[i-1][j-1]<mn) mn=dp[i-1][j-1];\n            dp[i][j]=mn+1;\n        }\n    }\n    return dp[n][m]; }",
        "hints": "dp[i][j] = min(insert, delete, replace)."
    },
    {
        "id": "c-h-10",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "language": "c",
        "description": "Implement regex matching with '.' and '*' using DP.",
        "examples": "Input: \"aab\", pattern=\"c*a*b\" → true",
        "solution": "bool isMatch(char* s, char* p){ int n=strlen(s), m=strlen(p);\n    int dp[510][510]={0}; dp[0][0]=1;\n    for(int j=2;j<=m;j++) if(p[j-1]=='*') dp[0][j]=dp[0][j-2];\n    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\n        if(p[j-1]=='.' || p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1];\n        else if(p[j-1]=='*'){\n            dp[i][j] = dp[i][j-2];\n            if(p[j-2]=='.' || p[j-2]==s[i-1]) dp[i][j] |= dp[i-1][j];\n        }\n    }\n    return dp[n][m]; }",
        "hints": "Star matches zero or more of preceding char."
    }
]