[
    {
        "id": "c-m-1",
        "title": "Add Two Numbers (Linked List)",
        "difficulty": "Medium",
        "language": "c",
        "description": "Two non-negative integers are stored in reverse order in two linked lists. Add them and return the sum as a linked list.",
        "examples": "Input: l1=[2,4,3], l2=[5,6,4]\nOutput: [7,0,8]",
        "solution": "struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->val = 0; dummy->next = NULL;\n    struct ListNode* cur = dummy;\n    int carry = 0;\n    while(l1 || l2 || carry) {\n        int x = l1 ? l1->val : 0;\n        int y = l2 ? l2->val : 0;\n        int sum = x + y + carry;\n        carry = sum / 10;\n        cur->next = malloc(sizeof(struct ListNode));\n        cur = cur->next;\n        cur->val = sum % 10;\n        cur->next = NULL;\n        if(l1) l1 = l1->next;\n        if(l2) l2 = l2->next;\n    }\n    return dummy->next;\n}",
        "hints": "Use carry and iterate until both lists and carry are exhausted."
    },
    {
        "id": "c-m-2",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "language": "c",
        "description": "Return length of longest substring without repeating characters using sliding window.",
        "examples": "Input: \"abcabcbb\" → 3",
        "solution": "int lengthOfLongestSubstring(char* s) {\n    int map[256];\n    for(int i=0;i<256;i++) map[i] = -1;\n    int left = 0, maxLen = 0;\n    for(int i=0;s[i];i++){\n        if(map[(unsigned char)s[i]] >= left)\n            left = map[(unsigned char)s[i]] + 1;\n        map[(unsigned char)s[i]] = i;\n        if(i - left + 1 > maxLen) maxLen = i - left + 1;\n    }\n    return maxLen;\n}",
        "hints": "Use last seen index array of size 256."
    },
    {
        "id": "c-m-3",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "language": "c",
        "description": "Search for a target in a rotated sorted array using binary search.",
        "examples": "Input: [4,5,6,7,0,1,2], target=0 → 4",
        "solution": "int search(int* nums, int numsSize, int target) {\n    int l=0, r=numsSize-1;\n    while(l<=r){\n        int m = (l+r)/2;\n        if(nums[m]==target) return m;\n        if(nums[l] <= nums[m]){\n            if(nums[l] <= target && target < nums[m]) r = m-1;\n            else l = m+1;\n        } else {\n            if(nums[m] < target && target <= nums[r]) l = m+1;\n            else r = m-1;\n        }\n    }\n    return -1;\n}",
        "hints": "Check individually which half is sorted."
    },
    {
        "id": "c-m-4",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "language": "c",
        "description": "Find max water container using two-pointer approach.",
        "examples": "Input: [1,8,6,2,5,4,8,3,7] → 49",
        "solution": "int maxArea(int* height, int heightSize) {\n    int l=0, r=heightSize-1;\n    int ans=0;\n    while(l<r){\n        int h = height[l] < height[r] ? height[l] : height[r];\n        int area = h * (r-l);\n        if(area > ans) ans = area;\n        if(height[l] < height[r]) l++;\n        else r--;\n    }\n    return ans;\n}",
        "hints": "Move pointer at shorter height."
    },
    {
        "id": "c-m-5",
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "language": "c",
        "description": "Find the kth largest element. Here solution uses sorting.",
        "examples": "Input: nums=[3,2,1,5,6,4], k=2 → 5",
        "solution": "int cmp(const void* a, const void* b){ return *(int*)b - *(int*)a; }\nint findKthLargest(int* nums, int numsSize, int k) {\n    qsort(nums, numsSize, sizeof(int), cmp);\n    return nums[k-1];\n}",
        "hints": "Quickselect can optimize but sorting works fine."
    },
    {
        "id": "c-m-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Medium",
        "language": "c",
        "description": "Return k most frequent elements. Frequency bucket method used.",
        "examples": "Input: [1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "typedef struct { int val, freq; } Pair;\nint* topKFrequent(int* nums, int numsSize, int k, int* returnSize){\n    int freq[20001]={0};\n    for(int i=0;i<numsSize;i++) freq[nums[i]+10000]++;\n    Pair arr[20001]; int n=0;\n    for(int i=0;i<20001;i++) if(freq[i]>0){ arr[n].val=i-10000; arr[n].freq=freq[i]; n++; }\n    // sort pairs by frequency desc\n    for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(arr[j].freq > arr[i].freq){ Pair t=arr[i]; arr[i]=arr[j]; arr[j]=t; }\n    int* res = malloc(sizeof(int)*k);\n    for(int i=0;i<k;i++) res[i]=arr[i].val;\n    *returnSize=k;\n    return res;\n}",
        "hints": "Use frequency table indexed by +10000 offset."
    },
    {
        "id": "c-m-7",
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "language": "c",
        "description": "Compute product of array except self without division using prefix and suffix.",
        "examples": "Input: [1,2,3,4] → [24,12,8,6]",
        "solution": "int* productExceptSelf(int* nums, int numsSize, int* returnSize){\n    int* res = malloc(sizeof(int)*numsSize);\n    *returnSize = numsSize;\n    int prefix = 1;\n    for(int i=0;i<numsSize;i++){\n        res[i] = prefix;\n        prefix *= nums[i];\n    }\n    int suffix = 1;\n    for(int i=numsSize-1;i>=0;i--){\n        res[i] *= suffix;\n        suffix *= nums[i];\n    }\n    return res;\n}",
        "hints": "Compute prefix products first, then suffix."
    },
    {
        "id": "c-m-8",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "language": "c",
        "description": "Count connected groups of '1' in a grid using DFS.",
        "examples": "Input grid → 3 islands",
        "solution": "void dfs(char** g, int i, int j, int m, int n){\n    if(i<0||j<0||i>=m||j>=n||g[i][j]=='0') return;\n    g[i][j]='0';\n    dfs(g,i+1,j,m,n);\n    dfs(g,i-1,j,m,n);\n    dfs(g,i,j+1,m,n);\n    dfs(g,i,j-1,m,n);\n}\nint numIslands(char** grid, int gridSize, int* gridColSize){\n    int m=gridSize, n=gridColSize[0];\n    int count=0;\n    for(int i=0;i<m;i++) for(int j=0;j<n;j++)\n        if(grid[i][j]=='1'){ count++; dfs(grid,i,j,m,n); }\n    return count;\n}",
        "hints": "Each DFS eliminates an island."
    },
    {
        "id": "c-m-9",
        "title": "Coin Change",
        "difficulty": "Medium",
        "language": "c",
        "description": "Determine minimum number of coins needed to achieve amount using DP.",
        "examples": "coins=[1,2,5], amount=11 → 3",
        "solution": "int coinChange(int* coins, int coinsSize, int amount){\n    int dp[10001];\n    for(int i=0;i<=amount;i++) dp[i]=100000;\n    dp[0]=0;\n    for(int i=0;i<coinsSize;i++){\n        for(int j=coins[i]; j<=amount; j++){\n            if(dp[j-coins[i]] + 1 < dp[j]) dp[j] = dp[j-coins[i]] + 1;\n        }\n    }\n    return dp[amount] >= 100000 ? -1 : dp[amount];\n}",
        "hints": "Unbounded knapsack dynamic programming."
    },
    {
        "id": "c-m-10",
        "title": "Word Break",
        "difficulty": "Medium",
        "language": "c",
        "description": "Return whether string can be segmented into dictionary words.",
        "examples": "Input: \"leetcode\", dict=[\"leet\",\"code\"] → true",
        "solution": "bool wordBreak(char* s, char** dict, int dictSize){\n    int n=strlen(s);\n    int dp[1001]={0}; dp[0]=1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<i;j++){\n            if(dp[j]){\n                for(int k=0;k<dictSize;k++){\n                    int len=strlen(dict[k]);\n                    if(j+len==i && strncmp(s+j,dict[k],len)==0){ dp[i]=1; break; }\n                }\n            }\n            if(dp[i]) break;\n        }\n    }\n    return dp[n];\n}",
        "hints": "dp[i] means s[0..i) can be segmented."
    }
]