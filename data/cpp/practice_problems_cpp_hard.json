[
    {
        "id": "cpp-h-1",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.",
        "examples": "Input: [[1,4,5],[1,3,4],[2,6]] → [1,1,2,3,4,4,5,6]",
        "solution": "struct cmp { bool operator()(ListNode* a, ListNode* b) { return a->val > b->val; } };\nListNode* mergeKLists(vector<ListNode*>& lists) {\n    priority_queue<ListNode*, vector<ListNode*>, cmp> pq;\n    for(auto l : lists) if(l) pq.push(l);\n    ListNode dummy(0); ListNode* tail = &dummy;\n    while(!pq.empty()){\n        ListNode* node = pq.top(); pq.pop();\n        tail->next = node;\n        tail = tail->next;\n        if(node->next) pq.push(node->next);\n    }\n    return dummy.next;\n}",
        "hints": "Use a min-heap to keep track of the current smallest element among all lists."
    },
    {
        "id": "cpp-h-2",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": "Input: [0,1,0,2,1,0,1,3,2,1,2,1] → 6",
        "solution": "int trap(vector<int>& height) {\n    int l=0, r=height.size()-1, level=0, res=0;\n    while(l<r){\n        int lower = height[height[l]<height[r] ? l++ : r--];\n        level = max(level, lower);\n        res += level - lower;\n    }\n    return res;\n}",
        "hints": "Two pointers: water trapped at a position is determined by the shorter of the max heights on left and right."
    },
    {
        "id": "cpp-h-3",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window.",
        "examples": "Input: s=\"ADOBECODEBANC\", t=\"ABC\" → \"BANC\"",
        "solution": "string minWindow(string s, string t) {\n    vector<int> map(128,0);\n    for(char c: t) map[c]++;\n    int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\n    while(end<s.size()){\n        if(map[s[end++]]-- > 0) counter--;\n        while(counter==0){\n            if(end-begin < d) d=end-(head=begin);\n            if(map[s[begin++]]++==0) counter++;\n        }\n    }\n    return d==INT_MAX? \"\" : s.substr(head, d);\n}",
        "hints": "Use two pointers and a hash map (or array) to track character counts."
    },
    {
        "id": "cpp-h-4",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words such that adjacent words differ by one letter. Return the number of words in the shortest transformation sequence.",
        "examples": "Input: hit → cog, dict=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] → 5",
        "solution": "int ladderLength(string begin, string end, vector<string>& wordList) {\n    unordered_set<string> dict(wordList.begin(), wordList.end());\n    if(!dict.count(end)) return 0;\n    queue<string> q; q.push(begin);\n    int step=1;\n    while(!q.empty()){\n        int sz=q.size();\n        while(sz--){\n            string w = q.front(); q.pop();\n            if(w==end) return step;\n            for(int i=0;i<w.size();i++){\n                char c=w[i];\n                for(int j=0;j<26;j++){\n                    w[i]='a'+j;\n                    if(dict.count(w)){\n                        dict.erase(w);\n                        q.push(w);\n                    }\n                }\n                w[i]=c;\n            }\n        }\n        step++;\n    }\n    return 0;\n}",
        "hints": "BFS to find the shortest path in the graph of words."
    },
    {
        "id": "cpp-h-5",
        "title": "N-Queens",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Return all distinct solutions.",
        "examples": "Input: 4 → [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "solution": "vector<vector<string>> solveNQueens(int n) {\n    vector<vector<string>> res;\n    vector<string> board(n, string(n, '.'));\n    function<void(int,int,int,int)> dfs = [&](int r, int cols, int d1, int d2){\n        if(r==n){ res.push_back(board); return; }\n        int available = ((1<<n)-1) & ~(cols | d1 | d2);\n        while(available){\n            int p = available & -available;\n            available ^= p;\n            int c = __builtin_ctz(p);\n            board[r][c] = 'Q';\n            dfs(r+1, cols|p, (d1|p)<<1, (d2|p)>>1);\n            board[r][c] = '.';\n        }\n    };\n    dfs(0,0,0,0);\n    return res;\n}",
        "hints": "Backtracking with bitmasks for efficient column/diagonal checking."
    },
    {
        "id": "cpp-h-6",
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Design an algorithm to serialize and deserialize a binary tree.",
        "examples": "Input: [1,2,3,null,null,4,5]",
        "solution": "class Codec {\npublic:\n    string serialize(TreeNode* root) {\n        if(!root) return \"#\";\n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right);\n    }\n    TreeNode* deserialize(string data) {\n        stringstream ss(data); string val;\n        function<TreeNode*()> helper = [&]() -> TreeNode* {\n            if(!getline(ss, val, ',')) return NULL;\n            if(val==\"#\") return NULL;\n            TreeNode* n = new TreeNode(stoi(val));\n            n->left = helper(); n->right = helper();\n            return n;\n        };\n        return helper();\n    }\n};",
        "hints": "Preorder traversal is simple to implement."
    },
    {
        "id": "cpp-h-7",
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
        "examples": "Input: \"(()\" → 2",
        "solution": "int longestValidParentheses(string s) {\n    stack<int> st; st.push(-1);\n    int maxL=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='(') st.push(i);\n        else{\n            st.pop();\n            if(st.empty()) st.push(i);\n            else maxL = max(maxL, i-st.top());\n        }\n    }\n    return maxL;\n}",
        "hints": "Use a stack to store indices. Push -1 initially."
    },
    {
        "id": "cpp-h-8",
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Maximize coins collected by bursting balloons. Bursting balloon i gives nums[i-1]*nums[i]*nums[i+1].",
        "examples": "Input: [3,1,5,8] → 167",
        "solution": "int maxCoins(vector<int>& nums) {\n    int n=nums.size();\n    nums.insert(nums.begin(), 1); nums.push_back(1);\n    vector<vector<int>> dp(n+2, vector<int>(n+2, 0));\n    for(int len=1;len<=n;len++){\n        for(int i=1;i<=n-len+1;i++){\n            int j=i+len-1;\n            for(int k=i;k<=j;k++){\n                dp[i][j] = max(dp[i][j], dp[i][k-1] + nums[i-1]*nums[k]*nums[j+1] + dp[k+1][j]);\n            }\n        }\n    }\n    return dp[1][n];\n}",
        "hints": "Divide and conquer with DP. Consider the last balloon to burst."
    },
    {
        "id": "cpp-h-9",
        "title": "Edit Distance",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.",
        "examples": "Input: horse → ros → 3",
        "solution": "int minDistance(string w1, string w2) {\n    int m=w1.size(), n=w2.size();\n    vector<vector<int>> dp(m+1, vector<int>(n+1));\n    for(int i=0;i<=m;i++) dp[i][0]=i;\n    for(int j=0;j<=n;j++) dp[0][j]=j;\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\n            else dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\n        }\n    }\n    return dp[m][n];\n}",
        "hints": "DP state: minimal operations to convert prefix i to prefix j."
    },
    {
        "id": "cpp-h-10",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "language": "cpp",
        "description": "Implement regex matching with support for '.' and '*'.",
        "examples": "Input: \"aab\", \"c*a*b\" → true",
        "solution": "bool isMatch(string s, string p) {\n    int m=s.size(), n=p.size();\n    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\n    dp[0][0]=true;\n    for(int j=2;j<=n;j++) if(p[j-1]=='*') dp[0][j]=dp[0][j-2];\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            if(p[j-1]=='*'){\n                dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1]==p[j-2]||p[j-2]=='.'));\n            }\n            else dp[i][j] = dp[i-1][j-1] && (p[j-1]=='.'||s[i-1]==p[j-1]);\n        }\n    }\n    return dp[m][n];\n}",
        "hints": "Handle '*' by checking zero occurrence or one+ occurrence match."
    }
]