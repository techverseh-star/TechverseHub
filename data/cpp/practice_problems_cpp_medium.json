[
    {
        "id": "cpp-m-1",
        "title": "Add Two Numbers (Linked List)",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Given two linked lists representing two non-negative integers in reverse order, return their sum as a linked list.",
        "examples": "Input: [2,4,3] + [5,6,4] → [7,0,8]",
        "solution": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode* dummy = new ListNode(0);\n    ListNode* cur = dummy;\n    int carry = 0;\n    while(l1 || l2 || carry) {\n        int x = l1 ? l1->val : 0;\n        int y = l2 ? l2->val : 0;\n        int sum = x + y + carry;\n        carry = sum / 10;\n        cur->next = new ListNode(sum % 10);\n        cur = cur->next;\n        if(l1) l1 = l1->next;\n        if(l2) l2 = l2->next;\n    }\n    return dummy->next;\n}",
        "hints": "Use carry and iterate while any list has nodes."
    },
    {
        "id": "cpp-m-2",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Return length of longest substring without repeating characters using sliding window.",
        "examples": "Input: \"abcabcbb\" → 3",
        "solution": "int lengthOfLongestSubstring(string s) {\n    vector<int> last(256, -1);\n    int left = 0, ans = 0;\n    for(int i=0;i<s.size();i++){\n        if(last[s[i]] >= left) left = last[s[i]] + 1;\n        last[s[i]] = i;\n        ans = max(ans, i-left+1);\n    }\n    return ans;\n}",
        "hints": "Store last index of each character."
    },
    {
        "id": "cpp-m-3",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Search for target in rotated sorted array using binary search.",
        "examples": "Input: [4,5,6,7,0,1,2], target=0 → 4",
        "solution": "int search(vector<int>& nums, int target) {\n    int l=0, r=nums.size()-1;\n    while(l<=r){\n        int m=(l+r)/2;\n        if(nums[m]==target) return m;\n        if(nums[l] <= nums[m]){\n            if(nums[l] <= target && target < nums[m]) r=m-1;\n            else l=m+1;\n        } else {\n            if(nums[m] < target && target <= nums[r]) l=m+1;\n            else r=m-1;\n        }\n    }\n    return -1;\n}",
        "hints": "Check which side of array is sorted."
    },
    {
        "id": "cpp-m-4",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Compute max water area using two-pointer technique.",
        "examples": "Input: [1,8,6,2,5,4,8,3,7] → 49",
        "solution": "int maxArea(vector<int>& h) {\n    int l=0, r=h.size()-1, ans=0;\n    while(l<r){\n        ans = max(ans, min(h[l],h[r])*(r-l));\n        if(h[l]<h[r]) l++;\n        else r--;\n    }\n    return ans;\n}",
        "hints": "Move pointer at smaller height inward."
    },
    {
        "id": "cpp-m-5",
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Find kth largest element using sort or priority queue.",
        "examples": "Input: [3,2,1,5,6,4], k=2 → 5",
        "solution": "int findKthLargest(vector<int>& nums, int k) {\n    nth_element(nums.begin(), nums.begin()+k-1, nums.end(), greater<int>());\n    return nums[k-1];\n}",
        "hints": "nth_element runs in average O(n)."
    },
    {
        "id": "cpp-m-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Return k elements with highest frequency.",
        "examples": "Input: [1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    unordered_map<int,int> freq;\n    for(int n:nums) freq[n]++;\n    vector<vector<int>> bucket(nums.size()+1);\n    for(auto &p:freq) bucket[p.second].push_back(p.first);\n    vector<int> res;\n    for(int i=bucket.size()-1;i>=0 && res.size()<k;i--)\n        for(int n:bucket[i]){\n            res.push_back(n);\n            if(res.size()==k) break;\n        }\n    return res;\n}",
        "hints": "Use frequency bucket from 1..n."
    },
    {
        "id": "cpp-m-7",
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Return array where each element equals product of others without using division.",
        "examples": "Input: [1,2,3,4] → [24,12,8,6]",
        "solution": "vector<int> productExceptSelf(vector<int>& nums) {\n    int n=nums.size();\n    vector<int> res(n,1);\n    int prefix=1;\n    for(int i=0;i<n;i++) res[i]=prefix, prefix*=nums[i];\n    int suffix=1;\n    for(int i=n-1;i>=0;i--) res[i]*=suffix, suffix*=nums[i];\n    return res;\n}",
        "hints": "Prefix and suffix multipliers."
    },
    {
        "id": "cpp-m-8",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Count number of connected 1-islands using DFS.",
        "examples": "Input grid → 3",
        "solution": "void dfs(vector<vector<char>>& g, int i, int j){\n    if(i<0||j<0||i>=g.size()||j>=g[0].size()||g[i][j]=='0') return;\n    g[i][j]='0';\n    dfs(g,i+1,j); dfs(g,i-1,j);\n    dfs(g,i,j+1); dfs(g,i,j-1);\n}\nint numIslands(vector<vector<char>>& g){\n    int m=g.size(), n=g[0].size(), cnt=0;\n    for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(g[i][j]=='1'){\n        cnt++; dfs(g,i,j);\n    }\n    return cnt;\n}",
        "hints": "DFS wipes out visited land."
    },
    {
        "id": "cpp-m-9",
        "title": "Coin Change",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Compute minimum coins to reach amount using DP.",
        "examples": "Input: coins=[1,2,5], amount=11 → 3",
        "solution": "int coinChange(vector<int>& coins, int amount) {\n    vector<int> dp(amount+1, 1e9);\n    dp[0]=0;\n    for(int c:coins)\n        for(int i=c;i<=amount;i++)\n            dp[i] = min(dp[i], dp[i-c]+1);\n    return dp[amount] >= 1e9 ? -1 : dp[amount];\n}",
        "hints": "Unbounded knapsack DP."
    },
    {
        "id": "cpp-m-10",
        "title": "Word Break",
        "difficulty": "Medium",
        "language": "cpp",
        "description": "Determine if s can be segmented into dictionary words.",
        "examples": "Input: \"leetcode\", dict=[\"leet\",\"code\"] → true",
        "solution": "bool wordBreak(string s, vector<string>& dict) {\n    unordered_set<string> st(dict.begin(), dict.end());\n    vector<int> dp(s.size()+1,0);\n    dp[0]=1;\n    for(int i=1;i<=s.size();i++){\n        for(int j=0;j<i;j++){\n            if(dp[j] && st.count(s.substr(j,i-j))){ dp[i]=1; break; }\n        }\n    }\n    return dp[s.size()];\n}",
        "hints": "dp[i] means s[0..i) can be segmented."
    }
]