[
  {
    "id": "cpp-1",
    "title": "Console Text Editor",
    "language": "cpp",
    "difficulty": "Beginner",
    "duration": "3-4 hours",
    "description": "Build a text editor with file operations using C++ STL.",
    "overview": "Create a basic text editor that can open, edit, and save files.",
    "concepts": [
      "STL strings",
      "fstream",
      "Vectors",
      "OOP"
    ],
    "steps": [
      {
        "title": "Step 1 operations",
        "description": "Read and write files."
      },
      {
        "title": "Step 2 editing",
        "description": "Insert, delete, modify lines."
      },
      {
        "title": "Step 3",
        "description": "Show content with line numbers."
      }
    ],
    "starterCode": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass TextEditor {\n    vector<string> lines;\n    \npublic:\n    void loadFile(const string& filename) {\n        // TODO file into lines\n    }\n    \n    void saveFile(const string& filename) {\n        // TODO lines to file\n    }\n    \n    void display() {\n        // TODO with line numbers\n    }\n    \n    void insertLine(int pos, const string& text) {\n        // TODO line at position\n    }\n};\n\nint main() {\n    TextEditor editor;\n    editor.insertLine(0, \"Hello, World!\");\n    editor.insertLine(1, \"Welcome to C++\");\n    editor.display();\n    return 0;\n}\n",
    "solution": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass TextEditor {\n    vector<string> lines;\n    \npublic:\n    void loadFile(const string& filename) {\n        ifstream file(filename);\n        string line;\n        lines.clear();\n        while (getline(file, line)) {\n            lines.push_back(line);\n        }\n    }\n    \n    void saveFile(const string& filename) {\n        ofstream file(filename);\n        for (const auto& line : lines) {\n            file << line << \"\\n\";\n        }\n    }\n    \n    void display() {\n        for (size_t i = 0; i < lines.size(); i++) {\n            cout << i + 1 << \": \" << lines[i] << \"\\n\";\n        }\n    }\n    \n    void insertLine(int pos, const string& text) {\n        if (pos >= 0 && pos <= lines.size()) {\n            lines.insert(lines.begin() + pos, text);\n        }\n    }\n};\n\nint main() {\n    TextEditor editor;\n    editor.insertLine(0, \"Hello, World!\");\n    editor.insertLine(1, \"Welcome to C++\");\n    editor.insertLine(2, \"Text Editor Demo\");\n    editor.display();\n    return 0;\n}\n"
  },
  {
    "id": "cpp-2",
    "title": "Template-based Container Library",
    "language": "cpp",
    "difficulty": "Intermediate",
    "duration": "6-8 hours",
    "description": "Create generic containers using C++ templates.",
    "overview": "Build type-safe containers with template classes.",
    "concepts": [
      "Templates",
      "STL",
      "Iterators",
      "Operator overloading"
    ],
    "steps": [
      {
        "title": "Step 1 Stack",
        "description": "Generic stack implementation."
      },
      {
        "title": "Step 2 Queue",
        "description": "Generic queue implementation."
      },
      {
        "title": "Step 3",
        "description": "Add iterator support."
      }
    ],
    "starterCode": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T>\nclass Stack {\n    vector<T> data;\n    \npublic:\n    void push(const T& item) {\n        // TODO\n    }\n    \n    T pop() {\n        // TODO\n        return T();\n    }\n    \n    T& top() {\n        // TODO\n        return data.back();\n    }\n    \n    bool empty() const {\n        return data.empty();\n    }\n};\n\nint main() {\n    Stack<int> intStack;\n    intStack.push(1);\n    intStack.push(2);\n    cout << \"Top: \" << intStack.top() << endl;\n    return 0;\n}\n",
    "solution": "#include <iostream>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\ntemplate<typename T>\nclass Stack {\n    vector<T> data;\n    \npublic:\n    void push(const T& item) {\n        data.push_back(item);\n    }\n    \n    T pop() {\n        if (empty()) throw runtime_error(\"Stack empty\");\n        T item = data.back();\n        data.pop_back();\n        return item;\n    }\n    \n    T& top() {\n        if (empty()) throw runtime_error(\"Stack empty\");\n        return data.back();\n    }\n    \n    bool empty() const { return data.empty(); }\n    size_t size() const { return data.size(); }\n};\n\nint main() {\n    Stack<int> intStack;\n    intStack.push(10);\n    intStack.push(20);\n    intStack.push(30);\n    \n    while (!intStack.empty()) {\n        cout << intStack.pop() << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "id": "cpp-3",
    "title": "Memory Pool Allocator",
    "language": "cpp",
    "difficulty": "Advanced",
    "duration": "10-12 hours",
    "description": "Implement a custom memory pool for efficient allocation.",
    "overview": "Build a memory pool that pre-allocates memory for fast object creation.",
    "concepts": [
      "Memory management",
      "Placement new",
      "Templates",
      "RAII"
    ],
    "steps": [
      {
        "title": "Step 1 structure",
        "description": "Design memory pool layout."
      },
      {
        "title": "Step 2",
        "description": "Implement allocate/deallocate."
      },
      {
        "title": "Step 3 construction",
        "description": "Use placement new."
      }
    ],
    "starterCode": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\ntemplate<typename T, size_t PoolSize = 100>\nclass MemoryPool {\n    char* pool;\n    bool* used;\n    \npublic:\n    MemoryPool() {\n        pool = new char[sizeof(T) * PoolSize];\n        used = new bool[PoolSize]();\n    }\n    \n    ~MemoryPool() {\n        delete[] pool;\n        delete[] used;\n    }\n    \n    T* allocate() {\n        // TODO free slot and return pointer\n        return nullptr;\n    }\n    \n    void deallocate(T* ptr) {\n        // TODO slot as free\n    }\n};\n\nint main() {\n    MemoryPool<int, 10> pool;\n    int* p = pool.allocate();\n    *p = 42;\n    cout << \"Value: \" << *p << endl;\n    pool.deallocate(p);\n    return 0;\n}\n",
    "solution": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\ntemplate<typename T, size_t PoolSize = 100>\nclass MemoryPool {\n    char* pool;\n    bool* used;\n    \npublic:\n    MemoryPool() {\n        pool = new char[sizeof(T) * PoolSize];\n        used = new bool[PoolSize]();\n    }\n    \n    ~MemoryPool() {\n        delete[] pool;\n        delete[] used;\n    }\n    \n    T* allocate() {\n        for (size_t i = 0; i < PoolSize; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                return reinterpret_cast<T*>(pool + i * sizeof(T));\n            }\n        }\n        return nullptr;\n    }\n    \n    void deallocate(T* ptr) {\n        size_t idx = (reinterpret_cast<char*>(ptr) - pool) / sizeof(T);\n        if (idx < PoolSize) used[idx] = false;\n    }\n};\n\nint main() {\n    MemoryPool<int, 10> pool;\n    \n    int* nums[5];\n    for (int i = 0; i < 5; i++) {\n        nums[i] = pool.allocate();\n        *nums[i] = i * 10;\n    }\n    \n    for (int i = 0; i < 5; i++) {\n        cout << *nums[i] << \" \";\n        pool.deallocate(nums[i]);\n    }\n    cout << endl;\n    return 0;\n}\n"
  }
]