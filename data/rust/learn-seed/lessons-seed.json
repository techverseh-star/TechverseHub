[
  {
    "id": "rust-01",
    "title": "Introduction to Rust",
    "content": "Rust is a systems programming language focused on safety, performance, and concurrency.\nKey Features:\n- Memory safety without garbage collector\n- Ownership & Borrowing system\n- Zero-cost abstractions\n- High-performance\nUsed for OS development, game engines, CLI tools, and web backends.",
    "codeExample": "fn main() {\n    println!(\"Hello, Rust!\");\n}",
    "trystarter": "println!(\"Your first Rust program\");",
    "language": "rust"
  },
  {
    "id": "rust-02",
    "title": "Variables & Mutability",
    "content": "Variables are immutable by default. Use mut to make them mutable.\nRust is statically typed but supports type inference.",
    "codeExample": "let x = 5;\nlet mut y = 10;\ny = 20;",
    "trystarter": "let mut city = \"Delhi\";",
    "language": "rust"
  },
  {
    "id": "rust-03",
    "title": "Data Types",
    "content": "Common types:\n- Integers: i32, u32, i64\n- Floats: f32, f64\n- Bool\n- Char\n- String & str\nRust is strongly typed and supports explicit typing.",
    "codeExample": "let a: i32 = 10;\nlet b: f64 = 2.5;",
    "trystarter": "let flag: bool = true;",
    "language": "rust"
  },
  {
    "id": "rust-04",
    "title": "Ownership",
    "content": "Rust's core feature is ownership:\n1. Each value has a variable as its owner.\n2. Only one owner at a time.\n3. Value is dropped when owner goes out of scope.\nPrevents memory errors and double frees.",
    "codeExample": "let s = String::from(\"hello\");\nlet t = s; // ownership moves// println!(\"{}\", s); // error",
    "trystarter": "let name = String::from(\"Rust\");",
    "language": "rust"
  },
  {
    "id": "rust-05",
    "title": "Borrowing & References",
    "content": "Borrowing allows using data without taking ownership.\n& creates references.\nMutable and immutable borrow rules prevent data races.",
    "codeExample": "let s = String::from(\"hello\");\nlet len = calculate(&s);\nfn calculate(s: &String) -> usize { s.len() }",
    "trystarter": "let x = 5;\nlet r = &x;",
    "language": "rust"
  },
  {
    "id": "rust-06",
    "title": "Slices",
    "content": "Slices reference a portion of a collection.\nCommonly used for strings and arrays.",
    "codeExample": "let s = String::from(\"hello world\");\nlet part = &s[0..5];",
    "trystarter": "let nums = [1,2,3,4]; let slice = &nums[1..3];",
    "language": "rust"
  },
  {
    "id": "rust-07",
    "title": "Functions",
    "content": "Functions use fn keyword.\nReturn values use -> type.\nLast expression without semicolon becomes the return value.",
    "codeExample": "fn add(a: i32, b: i32) -> i32 { a + b }\nprintln!(\"{}\", add(2,3));",
    "trystarter": "fn greet(){ println!(\"hi\"); }",
    "language": "rust"
  },
  {
    "id": "rust-08",
    "title": "Control Flow",
    "content": "Rust supports if/else, loop, while, for.\nif is an expression and can return values.",
    "codeExample": "let x = if true { 1 } else { 0 };",
    "trystarter": "for i in 1..5 { println!(\"{}\", i); }",
    "language": "rust"
  },
  {
    "id": "rust-09",
    "title": "Structs",
    "content": "Structs group related data. Instantiate with field names. Use impl blocks for methods.",
    "codeExample": "struct Person { name: String, age: u32 }\nlet p = Person { name:\"Alice\".into(), age:25 };",
    "trystarter": "struct Car{ model:String }",
    "language": "rust"
  },
  {
    "id": "rust-10",
    "title": "Enums",
    "content": "Enums define multiple possible variants. Useful with match expressions.",
    "codeExample": "enum Color { Red, Green, Blue }\nlet c = Color::Red;",
    "trystarter": "enum State{ On, Off }",
    "language": "rust"
  },
  {
    "id": "rust-11",
    "title": "Pattern Matching",
    "content": "match compares a value against patterns.\nVery powerful alternative to switch.",
    "codeExample": "match c { Color::Red => println!(\"red\"), _ => println!(\"other\") }",
    "trystarter": "match 1 { 1=>println!(\"one\"), _=>() }",
    "language": "rust"
  },
  {
    "id": "rust-12",
    "title": "Traits",
    "content": "Traits define shared behavior like interfaces. Types implement traits using impl.",
    "codeExample": "trait Speak{ fn hi(&self); }\nstruct A;\nimpl Speak for A{ fn hi(&self){ println!(\"hi\") } }",
    "trystarter": "trait T{ fn f(&self); }",
    "language": "rust"
  },
  {
    "id": "rust-13",
    "title": "Error Handling",
    "content": "Rust uses Result<T,E> for recoverable errors.\n? operator propagates errors.",
    "codeExample": "fn read() -> Result<String, std::io::Error> {\n  std::fs::read_to_string(\"a.txt\")\n}",
    "trystarter": "let r: Result<i32,&str> = Ok(10);",
    "language": "rust"
  },
  {
    "id": "rust-14",
    "title": "Vectors",
    "content": "Vectors are growable arrays.\nUse vec![] macro.\nPush items using push().",
    "codeExample": "let mut v = vec![1,2,3]; v.push(4);",
    "trystarter": "let v = vec![\"a\",\"b\"];",
    "language": "rust"
  },
  {
    "id": "rust-15",
    "title": "Concurrency with Threads",
    "content": "Rust uses std::thread::spawn for multithreading.\nOwnership guarantees prevent data races.",
    "codeExample": "std::thread::spawn(|| { println!(\"hi\"); }).join().unwrap();",
    "trystarter": "std::thread::spawn(|| println!(\"thread\"));",
    "language": "rust"
  }
]