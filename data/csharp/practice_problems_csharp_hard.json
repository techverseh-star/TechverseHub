[
    {
        "id": "cs-h-1",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Given a string s, return the length of the longest substring without repeating characters using sliding window.",
        "examples": "\"abcabcbb\" → 3",
        "solution": "int LengthOfLongestSubstring(string s) {\n    var set = new HashSet<char>();\n    int left = 0, maxLen = 0;\n    for (int right = 0; right < s.Length; right++) {\n        while (set.Contains(s[right])) {\n            set.Remove(s[left]);\n            left++;\n        }\n        set.Add(s[right]);\n        maxLen = Math.Max(maxLen, right - left + 1);\n    }\n    return maxLen;\n}",
        "hints": "Use HashSet + sliding window."
    },
    {
        "id": "cs-h-2",
        "title": "Word Break (DP)",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Given a string and word dictionary, determine if the string can be segmented.",
        "examples": "\"leetcode\", [\"leet\",\"code\"] → true",
        "solution": "bool WordBreak(string s, IList<string> wordDict) {\n    var set = new HashSet<string>(wordDict);\n    var dp = new bool[s.Length + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.Length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && set.Contains(s.Substring(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.Length];\n}",
        "hints": "dp[i] = true if substring 0..i can be built."
    },
    {
        "id": "cs-h-3",
        "title": "Binary Tree Level Order Traversal",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Return level order traversal of a binary tree using BFS.",
        "examples": "[3,9,20,null,null,15,7] → [[3],[9,20],[15,7]]",
        "solution": "IList<IList<int>> LevelOrder(TreeNode root) {\n    var res = new List<IList<int>>();\n    if (root == null) return res;\n    var q = new Queue<TreeNode>();\n    q.Enqueue(root);\n    while (q.Count > 0) {\n        int size = q.Count;\n        var level = new List<int>();\n        while (size-- > 0) {\n            var node = q.Dequeue();\n            level.Add(node.val);\n            if (node.left != null) q.Enqueue(node.left);\n            if (node.right != null) q.Enqueue(node.right);\n        }\n        res.Add(level);\n    }\n    return res;\n}",
        "hints": "Use queue BFS."
    },
    {
        "id": "cs-h-4",
        "title": "Combination Sum",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Find all unique combinations where candidates sum to target.",
        "examples": "[2,3,6,7], target=7 → [[2,2,3],[7]]",
        "solution": "IList<IList<int>> CombinationSum(int[] candidates, int target) {\n    var res = new List<IList<int>>();\n    void Backtrack(int start, int remain, List<int> path) {\n        if (remain == 0) { res.Add(new List<int>(path)); return; }\n        if (remain < 0) return;\n        for (int i = start; i < candidates.Length; i++) {\n            path.Add(candidates[i]);\n            Backtrack(i, remain - candidates[i], path);\n            path.RemoveAt(path.Count - 1);\n        }\n    }\n    Backtrack(0, target, new List<int>());\n    return res;\n}",
        "hints": "Recursive backtracking."
    },
    {
        "id": "cs-h-5",
        "title": "Merge Intervals",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Given intervals, merge overlapping intervals.",
        "examples": "[[1,3],[2,6],[8,10]] → [[1,6],[8,10]]",
        "solution": "int[][] Merge(int[][] intervals) {\n    intervals = intervals.OrderBy(i => i[0]).ToArray();\n    var res = new List<int[]>();\n    var cur = intervals[0];\n    foreach (var next in intervals.Skip(1)) {\n        if (next[0] <= cur[1]) cur[1] = Math.Max(cur[1], next[1]);\n        else { res.Add(cur); cur = next; }\n    }\n    res.Add(cur);\n    return res.ToArray();\n}",
        "hints": "Sort and merge."
    },
    {
        "id": "cs-h-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Return k most frequent numbers.",
        "examples": "[1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "IList<int> TopKFrequent(int[] nums, int k) {\n    var freq = nums.GroupBy(x => x).ToDictionary(g => g.Key, g => g.Count());\n    return freq.OrderByDescending(p => p.Value).Take(k).Select(p => p.Key).ToList();\n}",
        "hints": "GroupBy + sort."
    },
    {
        "id": "cs-h-7",
        "title": "Longest Increasing Subsequence",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Return length of LIS using binary search optimized DP.",
        "examples": "[10,9,2,5,3,7,101,18] → 4",
        "solution": "int LengthOfLIS(int[] nums) {\n    var dp = new List<int>();\n    foreach (var n in nums) {\n        int idx = dp.BinarySearch(n);\n        if (idx < 0) idx = ~idx;\n        if (idx == dp.Count) dp.Add(n);\n        else dp[idx] = n;\n    }\n    return dp.Count;\n}",
        "hints": "Use patience sorting method."
    },
    {
        "id": "cs-h-8",
        "title": "Number of Islands",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Count number of islands in a 2D grid using DFS flood-fill.",
        "examples": "[[1,1,0],[0,1,0]] → 1",
        "solution": "int NumIslands(char[][] grid) {\n    int rows = grid.Length, cols = grid[0].Length;\n    int count = 0;\n    void Dfs(int r, int c) {\n        if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] == '0') return;\n        grid[r][c] = '0';\n        Dfs(r+1,c); Dfs(r-1,c); Dfs(r,c+1); Dfs(r,c-1);\n    }\n    for (int r = 0; r < rows; r++)\n        for (int c = 0; c < cols; c++)\n            if (grid[r][c] == '1') { count++; Dfs(r,c); }\n    return count;\n}",
        "hints": "DFS flood fill."
    },
    {
        "id": "cs-h-9",
        "title": "Group Anagrams",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Group strings that are anagrams using sorted key.",
        "examples": "[\"eat\",\"tea\",\"ate\"] → [[\"eat\",\"tea\",\"ate\"]]",
        "solution": "IList<IList<string>> GroupAnagrams(string[] strs) {\n    var map = new Dictionary<string,List<string>>();\n    foreach (var s in strs) {\n        string key = String.Concat(s.OrderBy(c => c));\n        if (!map.ContainsKey(key)) map[key] = new List<string>();\n        map[key].Add(s);\n    }\n    return map.Values.ToList();\n}",
        "hints": "Sort characters to form grouping key."
    },
    {
        "id": "cs-h-10",
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Hard",
        "language": "c#",
        "description": "Evaluate the value of an RPN expression.",
        "examples": "[\"2\",\"1\",\"+\",\"3\",\"*\"] → 9",
        "solution": "int EvalRPN(string[] tokens) {\n    var stack = new Stack<int>();\n    foreach (var t in tokens) {\n        if (int.TryParse(t, out int val)) stack.Push(val);\n        else {\n            int b = stack.Pop();\n            int a = stack.Pop();\n            switch (t) {\n                case \"+\": stack.Push(a + b); break;\n                case \"-\": stack.Push(a - b); break;\n                case \"*\": stack.Push(a * b); break;\n                case \"/\": stack.Push(a / b); break;\n            }\n        }\n    }\n    return stack.Peek();\n}",
        "hints": "Use stack to evaluate operators."
    }
]
