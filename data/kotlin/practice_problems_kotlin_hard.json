[
    {
        "id": "kt-h-1",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Given a string s, find the length of the longest substring without repeating characters using sliding window.",
        "examples": "\"abcabcbb\" → 3",
        "solution": "fun lengthOfLongestSubstring(s: String): Int {\n    val set = HashSet<Char>()\n    var left = 0\n    var maxLen = 0\n    for (right in s.indices) {\n        while (set.contains(s[right])) {\n            set.remove(s[left])\n            left++\n        }\n        set.add(s[right])\n        maxLen = maxOf(maxLen, right - left + 1)\n    }\n    return maxLen\n}",
        "hints": "Use a sliding window with a HashSet."
    },
    {
        "id": "kt-h-2",
        "title": "Word Break",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Given a string s and a dictionary of words, determine if s can be segmented into one or more dictionary words.",
        "examples": "s=\"leetcode\", dict=[\"leet\",\"code\"] → true",
        "solution": "fun wordBreak(s: String, dict: List<String>): Boolean {\n    val wordSet = dict.toSet()\n    val dp = BooleanArray(s.length+1)\n    dp[0] = true\n    for (i in 1..s.length) {\n        for (j in 0 until i) {\n            if (dp[j] && s.substring(j, i) in wordSet) {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[s.length]\n}",
        "hints": "Use DP: dp[i] = true if s[0..i) can be segmented."
    },
    {
        "id": "kt-h-3",
        "title": "Binary Tree Level Order Traversal",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Return the level-order traversal of a binary tree using BFS.",
        "examples": "Input: [3,9,20,null,null,15,7] → [[3],[9,20],[15,7]]",
        "solution": "data class TreeNode(var value:Int, var left:TreeNode?=null, var right:TreeNode?=null)\nfun levelOrder(root: TreeNode?): List<List<Int>> {\n    if (root==null) return listOf()\n    val q = ArrayDeque<TreeNode>()\n    val res = mutableListOf<List<Int>>()\n    q.add(root)\n    while (q.isNotEmpty()) {\n        val size = q.size\n        val level = mutableListOf<Int>()\n        repeat(size) {\n            val node = q.removeFirst()\n            level.add(node.value)\n            node.left?.let{q.add(it)}\n            node.right?.let{q.add(it)}\n        }\n        res.add(level)\n    }\n    return res\n}",
        "hints": "Use queue (BFS) to process nodes level by level."
    },
    {
        "id": "kt-h-4",
        "title": "Combination Sum",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Return all combinations where candidates sum to target. You may reuse numbers.",
        "examples": "candidates=[2,3,6,7], target=7 → [[2,2,3],[7]]",
        "solution": "fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {\n    val result = mutableListOf<List<Int>>()\n    fun backtrack(start:Int, remain:Int, path:MutableList<Int>) {\n        if (remain==0) {\n            result.add(path.toList())\n            return\n        }\n        if (remain<0) return\n        for (i in start until candidates.size) {\n            path.add(candidates[i])\n            backtrack(i, remain - candidates[i], path)\n            path.removeAt(path.size-1)\n        }\n    }\n    backtrack(0, target, mutableListOf())\n    return result\n}",
        "hints": "Use backtracking with reusable choices."
    },
    {
        "id": "kt-h-5",
        "title": "Merge Intervals",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Given intervals, merge all overlapping intervals.",
        "examples": "[[1,3],[2,6],[8,10]] → [[1,6],[8,10]]",
        "solution": "fun merge(intervals: Array<IntArray>): Array<IntArray> {\n    intervals.sortBy{it[0]}\n    val result = mutableListOf<IntArray>()\n    var current = intervals[0]\n    for (i in 1 until intervals.size) {\n        val next = intervals[i]\n        if (next[0] <= current[1]) current[1] = maxOf(current[1], next[1])\n        else {\n            result.add(current)\n            current = next\n        }\n    }\n    result.add(current)\n    return result.toTypedArray()\n}",
        "hints": "Sort by start & merge overlaps."
    },
    {
        "id": "kt-h-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Return the k most frequent numbers from array.",
        "examples": "nums=[1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "fun topKFrequent(nums:IntArray, k:Int): IntArray {\n    val freq = HashMap<Int,Int>()\n    for (n in nums) freq[n] = freq.getOrDefault(n,0)+1\n    return freq.entries.sortedByDescending{it.value}.take(k).map{it.key}.toIntArray()\n}",
        "hints": "Use frequency map + sort."
    },
    {
        "id": "kt-h-7",
        "title": "Longest Increasing Subsequence",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Return the length of LIS in nums.",
        "examples": "[10,9,2,5,3,7,101,18] → 4",
        "solution": "fun lengthOfLIS(nums:IntArray):Int{\n    val dp = mutableListOf<Int>()\n    for (n in nums) {\n        val idx = dp.binarySearch(n)\n        val pos = if (idx < 0) -idx - 1 else idx\n        if (pos == dp.size) dp.add(n) else dp[pos] = n\n    }\n    return dp.size\n}",
        "hints": "Use binary-search based patience sorting."
    },
    {
        "id": "kt-h-8",
        "title": "Permutations",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Return all permutations of array nums.",
        "examples": "[1,2,3] → [[1,2,3],[1,3,2]...]",
        "solution": "fun permute(nums:IntArray):List<List<Int>>{\n    val result = mutableListOf<List<Int>>()\n    fun backtrack(path:MutableList<Int>, used:BooleanArray){\n        if(path.size==nums.size){result.add(path.toList());return}\n        for(i in nums.indices){\n            if(used[i]) continue\n            used[i]=true\n            path.add(nums[i])\n            backtrack(path,used)\n            path.removeAt(path.size-1)\n            used[i]=false\n        }\n    }\n    backtrack(mutableListOf(), BooleanArray(nums.size))\n    return result\n}",
        "hints": "Use backtracking with used[] array."
    },
    {
        "id": "kt-h-9",
        "title": "Number of Islands",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Count number of islands in a 2D grid using DFS.",
        "examples": "[[1,1,0],[0,1,0]] → 1",
        "solution": "fun numIslands(grid:Array<CharArray>):Int{\n    var count=0\n    val dirs = arrayOf(intArrayOf(1,0), intArrayOf(-1,0), intArrayOf(0,1), intArrayOf(0,-1))\n    fun dfs(r:Int,c:Int){\n        if(r !in grid.indices || c !in grid[0].indices || grid[r][c]=='0') return\n        grid[r][c]='0'\n        for(d in dirs) dfs(r+d[0], c+d[1])\n    }\n    for(r in grid.indices) for(c in grid[0].indices){\n        if(grid[r][c]=='1'){count++;dfs(r,c)}\n    }\n    return count\n}",
        "hints": "Turn 1 → 0 when visited."
    },
    {
        "id": "kt-h-10",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "kotlin",
        "description": "Given s and t, return the minimum window in s that contains all characters of t.",
        "examples": "s=\"ADOBECODEBANC\", t=\"ABC\" → \"BANC\"",
        "solution": "fun minWindow(s:String,t:String):String{\n    if(t.isEmpty()) return \"\"\n    val need = HashMap<Char,Int>()\n    t.forEach{need[it]=need.getOrDefault(it,0)+1}\n    var have=0\n    var left=0\n    var minLen=Int.MAX_VALUE\n    var res=\"\"\n    val window = HashMap<Char,Int>()\n    for(right in s.indices){\n        val c=s[right]\n        window[c]=window.getOrDefault(c,0)+1\n        if(need.containsKey(c) && window[c]==need[c]) have++\n        while(have==need.size){\n            if(right-left+1<minLen){\n                minLen=right-left+1\n                res=s.substring(left,right+1)\n            }\n            val lc=s[left]\n            window[lc]=window[lc]!!-1\n            if(need.containsKey(lc) && window[lc]!!<need[lc]!!) have--\n            left++\n        }\n    }\n    return res\n}",
        "hints": "Sliding window + frequency match count."
    }
]