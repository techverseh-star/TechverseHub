[
    {
        "id": "java-e-1",
        "title": "Two Sum",
        "difficulty": "Easy",
        "language": "java",
        "description": "Given an array of integers nums and an integer target, return the indices of the two numbers that add up to the target. You may assume exactly one solution exists. You may not use the same element twice.",
        "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: nums[0] + nums[1] = 2 + 7 = 9.",
        "solution": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[]{ map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[]{};\n    }\n}",
        "hints": "Use HashMap for O(1) lookup."
    },
    {
        "id": "java-e-2",
        "title": "Reverse String",
        "difficulty": "Easy",
        "language": "java",
        "description": "Write a function that reverses a character array in-place using a two-pointer approach.",
        "examples": "Input: ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']",
        "solution": "class Solution {\n    public void reverseString(char[] s) {\n        int l = 0, r = s.length - 1;\n        while (l < r) {\n            char temp = s[l];\n            s[l] = s[r];\n            s[r] = temp;\n            l++; r--;\n        }\n    }\n}",
        "hints": "Swap characters using two-pointer technique."
    },
    {
        "id": "java-e-3",
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "language": "java",
        "description": "Check if two strings are anagrams by comparing character frequencies.",
        "examples": "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
        "solution": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for (int c : count) if (c != 0) return false;\n        return true;\n    }\n}",
        "hints": "Use an int[26] counter array."
    },
    {
        "id": "java-e-4",
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "language": "java",
        "description": "Determine if an integer array contains any duplicate values.",
        "examples": "Input: [1,2,3,1]\nOutput: true",
        "solution": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int n : nums) {\n            if (!set.add(n)) return true;\n        }\n        return false;\n    }\n}",
        "hints": "Use HashSet to detect duplicates."
    },
    {
        "id": "java-e-5",
        "title": "Maximum Subarray (Kadane's Algorithm)",
        "difficulty": "Easy",
        "language": "java",
        "description": "Find the contiguous subarray with the largest sum.",
        "examples": "Input: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6",
        "solution": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxSum = nums[0];\n        int cur = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            cur = Math.max(nums[i], cur + nums[i]);\n            maxSum = Math.max(maxSum, cur);\n        }\n        return maxSum;\n    }\n}",
        "hints": "Track running sum; reset when sum becomes negative."
    },
    {
        "id": "java-e-6",
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "language": "java",
        "description": "Merge two sorted linked lists into a new sorted list.",
        "examples": "Input: [1,2,4], [1,3,4]\nOutput: [1,1,2,3,4,4]",
        "solution": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode tail = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                tail.next = l1;\n                l1 = l1.next;\n            } else {\n                tail.next = l2;\n                l2 = l2.next;\n            }\n            tail = tail.next;\n        }\n        tail.next = (l1 != null) ? l1 : l2;\n        return dummy.next;\n    }\n}",
        "hints": "Use dummy head to simplify linking."
    },
    {
        "id": "java-e-7",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "language": "java",
        "description": "Find the maximum profit from one buy-sell transaction.",
        "examples": "Input: [7,1,5,3,6,4]\nOutput: 5",
        "solution": "class Solution {\n    public int maxProfit(int[] prices) {\n        int min = Integer.MAX_VALUE;\n        int profit = 0;\n        for (int p : prices) {\n            if (p < min) min = p;\n            else profit = Math.max(profit, p - min);\n        }\n        return profit;\n    }\n}",
        "hints": "Track minimum price seen so far."
    },
    {
        "id": "java-e-8",
        "title": "Single Number",
        "difficulty": "Easy",
        "language": "java",
        "description": "Every element appears twice except one. Find the unique element using XOR.",
        "examples": "Input: [2,2,1]\nOutput: 1",
        "solution": "class Solution {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for (int n : nums) res ^= n;\n        return res;\n    }\n}",
        "hints": "XOR cancels duplicates."
    },
    {
        "id": "java-e-9",
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "language": "java",
        "description": "Return the intersection of two arrays including duplicate appearances.",
        "examples": "Input: [1,2,2,1], [2,2]\nOutput: [2,2]",
        "solution": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int n : nums1) map.put(n, map.getOrDefault(n, 0) + 1);\n        List<Integer> res = new ArrayList<>();\n        for (int n : nums2) {\n            if (map.getOrDefault(n, 0) > 0) {\n                res.add(n);\n                map.put(n, map.get(n) - 1);\n            }\n        }\n        return res.stream().mapToInt(i -> i).toArray();\n    }\n}",
        "hints": "Count smaller array to save memory."
    },
    {
        "id": "java-e-10",
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "language": "java",
        "description": "Validate a parentheses string using stack.",
        "examples": "Input: \"()[]{}\"\nOutput: true",
        "solution": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '[' || c == '{') stack.push(c);\n            else {\n                if (stack.isEmpty()) return false;\n                char t = stack.pop();\n                if ((c == ')' && t != '(') ||\n                    (c == ']' && t != '[') ||\n                    (c == '}' && t != '{')) return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}",
        "hints": "Push opening brackets; match when closing bracket appears."
    }
]