[
    {
        "id": "java-m-1",
        "title": "Add Two Numbers (Linked List)",
        "difficulty": "Medium",
        "language": "java",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
        "examples": "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
        "solution": "class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }\n\nclass Solution {\n  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummy;\n    int carry = 0;\n    while (p != null || q != null) {\n      int x = (p != null) ? p.val : 0;\n      int y = (q != null) ? q.val : 0;\n      int sum = carry + x + y;\n      carry = sum / 10;\n      curr.next = new ListNode(sum % 10);\n      curr = curr.next;\n      if (p != null) p = p.next;\n      if (q != null) q = q.next;\n    }\n    if (carry > 0) curr.next = new ListNode(carry);\n    return dummy.next;\n  }\n}",
        "hints": "Use single pass over both lists, track carry, and use dummy head to build the result."
    },
    {
        "id": "java-m-2",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "language": "java",
        "description": "Given a string s, find the length of the longest substring without repeating characters. Use sliding window with a map of last seen positions.",
        "examples": "Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\".",
        "solution": "class Solution {\n  public int lengthOfLongestSubstring(String s) {\n    Map<Character, Integer> last = new HashMap<>();\n    int start = 0, maxLen = 0;\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      if (last.containsKey(c)) start = Math.max(start, last.get(c) + 1);\n      last.put(c, i);\n      maxLen = Math.max(maxLen, i - start + 1);\n    }\n    return maxLen;\n  }\n}",
        "hints": "Track last index of each character; move start pointer to lastIndex+1 when repeat is inside window."
    },
    {
        "id": "java-m-3",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "language": "java",
        "description": "An array sorted in ascending order is rotated at an unknown pivot. Given target, return its index or -1. Use modified binary search to keep O(log n).",
        "examples": "Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4",
        "solution": "class Solution {\n  public int search(int[] nums, int target) {\n    int l = 0, r = nums.length - 1;\n    while (l <= r) {\n      int m = (l + r) >>> 1;\n      if (nums[m] == target) return m;\n      if (nums[l] <= nums[m]) {\n        if (nums[l] <= target && target < nums[m]) r = m - 1;\n        else l = m + 1;\n      } else {\n        if (nums[m] < target && target <= nums[r]) l = m + 1;\n        else r = m - 1;\n      }\n    }\n    return -1;\n  }\n}",
        "hints": "Decide which half is sorted; check if target lies in that half."
    },
    {
        "id": "java-m-4",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "language": "java",
        "description": "Given heights representing vertical lines at unit distance, find two lines that, together with the x-axis, contain the most water. Use two-pointer technique.",
        "examples": "Input: [1,8,6,2,5,4,8,3,7]\nOutput: 49",
        "solution": "class Solution {\n  public int maxArea(int[] height) {\n    int l = 0, r = height.length - 1, max = 0;\n    while (l < r) {\n      int h = Math.min(height[l], height[r]);\n      max = Math.max(max, h * (r - l));\n      if (height[l] < height[r]) l++; else r--;\n    }\n    return max;\n  }\n}",
        "hints": "Move the pointer at the shorter line inward; only that can increase area."
    },
    {
        "id": "java-m-5",
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "language": "java",
        "description": "Find the k-th largest element in an unsorted array. Use a min-heap of size k or Quickselect for average O(n).",
        "examples": "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
        "solution": "class Solution {\n  public int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    for (int n : nums) {\n      pq.offer(n);\n      if (pq.size() > k) pq.poll();\n    }\n    return pq.peek();\n  }\n}",
        "hints": "Maintain min-heap of k largest elements; root is kth largest."
    },
    {
        "id": "java-m-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Medium",
        "language": "java",
        "description": "Return the k most frequent elements from the array. Use frequency map + heap or bucket sort.",
        "examples": "Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]",
        "solution": "class Solution {\n  public int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int n : nums) freq.put(n, freq.getOrDefault(n,0)+1);\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->freq.get(a)-freq.get(b));\n    for (int n : freq.keySet()) {\n      pq.offer(n);\n      if (pq.size() > k) pq.poll();\n    }\n    int[] res = new int[k];\n    for (int i = k-1; i >= 0; i--) res[i] = pq.poll();\n    return res;\n  }\n}",
        "hints": "Use min-heap sized k ordered by frequency, or bucket-sort by frequency for O(n)."
    },
    {
        "id": "java-m-7",
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "language": "java",
        "description": "Given an array nums, return an array output where output[i] is the product of all the elements of nums except nums[i], without using division and in O(n).",
        "examples": "Input: [1,2,3,4]\nOutput: [24,12,8,6]",
        "solution": "class Solution {\n  public int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] out = new int[n];\n    out[0] = 1;\n    for (int i = 1; i < n; i++) out[i] = out[i-1] * nums[i-1];\n    int suffix = 1;\n    for (int i = n-1; i >= 0; i--) {\n      out[i] *= suffix;\n      suffix *= nums[i];\n    }\n    return out;\n  }\n}",
        "hints": "Compute prefix products in out[], then multiply by suffix products computed in reverse pass."
    },
    {
        "id": "java-m-8",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "language": "java",
        "description": "Given a grid of '1's (land) and '0's (water), count islands (connected '1's vertically or horizontally). Use DFS/BFS to mark visited land.",
        "examples": "Input:\n[[\"1\",\"1\",\"0\",\"0\",\"0\"],\n [\"1\",\"1\",\"0\",\"0\",\"0\"],\n [\"0\",\"0\",\"1\",\"0\",\"0\"],\n [\"0\",\"0\",\"0\",\"1\",\"1\"]]\nOutput: 3",
        "solution": "class Solution {\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n    int m = grid.length, n = grid[0].length, count = 0;\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++)\n        if (grid[i][j] == '1') { count++; dfs(grid,i,j,m,n); }\n    return count;\n  }\n  private void dfs(char[][] g,int i,int j,int m,int n){\n    if(i<0||j<0||i>=m||j>=n||g[i][j]!='1') return;\n    g[i][j]='0';\n    dfs(g,i+1,j,m,n); dfs(g,i-1,j,m,n); dfs(g,i,j+1,m,n); dfs(g,i,j-1,m,n);\n  }\n}",
        "hints": "Mark visited cells to avoid recount; use stack/recursion (DFS) or queue (BFS)."
    },
    {
        "id": "java-m-9",
        "title": "Coin Change",
        "difficulty": "Medium",
        "language": "java",
        "description": "Given coins of different denominations and a total amount, compute the fewest number of coins to make up that amount. Dynamic programming solution (unbounded knapsack).",
        "examples": "Input: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 5 + 5 + 1",
        "solution": "class Solution {\n  public int coinChange(int[] coins, int amount) {\n    int max = amount + 1;\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, max);\n    dp[0] = 0;\n    for (int coin : coins) {\n      for (int i = coin; i <= amount; i++) dp[i] = Math.min(dp[i], dp[i-coin] + 1);\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n  }\n}",
        "hints": "1D DP: dp[x] = min coins to make amount x; iterate coins then amounts to allow reuse."
    },
    {
        "id": "java-m-10",
        "title": "Word Break",
        "difficulty": "Medium",
        "language": "java",
        "description": "Given a string s and a dictionary wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Use dynamic programming.",
        "examples": "Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true",
        "solution": "class Solution {\n  public boolean wordBreak(String s, List<String> wordDict) {\n    int n = s.length();\n    boolean[] dp = new boolean[n+1];\n    dp[0] = true;\n    Set<String> set = new HashSet<>(wordDict);\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j < i; j++) {\n        if (dp[j] && set.contains(s.substring(j,i))) { dp[i] = true; break; }\n      }\n    }\n    return dp[n];\n  }\n}",
        "hints": "dp[i] means prefix of length i can be segmented; iterate previous cut positions and check dictionary membership."
    }
]