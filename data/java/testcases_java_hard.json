[
    {
        "id": "java-h-1",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "language": "java",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n, return the median of the two sorted arrays. The algorithm must run in O(log (m+n)) time using binary search on partitions.",
        "examples": "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.0\nInput: nums1=[1,2], nums2=[3,4]\nOutput: 2.5",
        "solution": "class Solution {\n  public double findMedianSortedArrays(int[] A, int[] B) {\n    if (A.length > B.length) return findMedianSortedArrays(B, A);\n    int m = A.length, n = B.length;\n    int low = 0, high = m;\n    while (low <= high) {\n      int i = (low + high) / 2;\n      int j = (m + n + 1) / 2 - i;\n      int Aleft = (i == 0) ? Integer.MIN_VALUE : A[i-1];\n      int Aright = (i == m) ? Integer.MAX_VALUE : A[i];\n      int Bleft = (j == 0) ? Integer.MIN_VALUE : B[j-1];\n      int Bright = (j == n) ? Integer.MAX_VALUE : B[j];\n      if (Aleft <= Bright && Bleft <= Aright) {\n        if ((m+n) % 2 == 0)\n          return ((double)Math.max(Aleft, Bleft) + Math.min(Aright, Bright)) / 2;\n        else\n          return Math.max(Aleft, Bleft);\n      } else if (Aleft > Bright) {\n        high = i - 1;\n      } else {\n        low = i + 1;\n      }\n    }\n    return 0.0;\n  }\n}",
        "hints": "Binary search on the smaller array. Handle partition edge cases with infinity sentinels."
    },
    {
        "id": "java-h-2",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "language": "java",
        "description": "Implement regex matching with support for '.' and '*'. '.' matches any character. '*' matches zero or more of the preceding element. Must use dynamic programming to avoid exponential recursion.",
        "examples": "Input: s = \"aab\", p = \"c*a*b\"\nOutput: true",
        "solution": "class Solution {\n  public boolean isMatch(String s, String p) {\n    boolean[][] dp = new boolean[s.length()+1][p.length()+1];\n    dp[0][0] = true;\n    for (int j = 2; j <= p.length(); j++)\n      if (p.charAt(j-1) == '*') dp[0][j] = dp[0][j-2];\n    for (int i = 1; i <= s.length(); i++) {\n      for (int j = 1; j <= p.length(); j++) {\n        char sc = s.charAt(i-1), pc = p.charAt(j-1);\n        if (pc == '.' || pc == sc) dp[i][j] = dp[i-1][j-1];\n        else if (pc == '*') {\n          dp[i][j] = dp[i][j-2];\n          char prev = p.charAt(j-2);\n          if (prev == '.' || prev == sc) dp[i][j] |= dp[i-1][j];\n        }\n      }\n    }\n    return dp[s.length()][p.length()];\n  }\n}",
        "hints": "dp[i][j] = does s[0..i) match p[0..j). '*' can mean use-or-skip previous character."
    },
    {
        "id": "java-h-3",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "language": "java",
        "description": "Given n elevation heights, compute how much rainwater can be trapped after raining. Solve using two pointers in O(n) time and O(1) space.",
        "examples": "Input: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6",
        "solution": "class Solution {\n  public int trap(int[] h) {\n    int l = 0, r = h.length-1, leftMax = 0, rightMax = 0, ans = 0;\n    while (l < r) {\n      if (h[l] < h[r]) {\n        if (h[l] >= leftMax) leftMax = h[l];\n        else ans += leftMax - h[l];\n        l++;\n      } else {\n        if (h[r] >= rightMax) rightMax = h[r];\n        else ans += rightMax - h[r];\n        r--;\n      }\n    }\n    return ans;\n  }\n}",
        "hints": "Move from the smaller height side; accumulate difference from max height on that side."
    },
    {
        "id": "java-h-4",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "language": "java",
        "description": "Given an array of k sorted linked lists, merge them into one sorted linked list using a min-heap.",
        "examples": "Input: [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
        "solution": "class Solution {\n  class NodeWrapper implements Comparable<NodeWrapper> {\n    ListNode node;\n    NodeWrapper(ListNode n){ node=n; }\n    public int compareTo(NodeWrapper o) { return node.val - o.node.val; }\n  }\n  public ListNode mergeKLists(ListNode[] lists) {\n    PriorityQueue<NodeWrapper> pq = new PriorityQueue<>();\n    for (ListNode n : lists) if (n != null) pq.add(new NodeWrapper(n));\n    ListNode dummy = new ListNode(0), tail = dummy;\n    while (!pq.isEmpty()) {\n      NodeWrapper w = pq.poll();\n      tail.next = w.node;\n      tail = tail.next;\n      if (w.node.next != null) pq.add(new NodeWrapper(w.node.next));\n    }\n    return dummy.next;\n  }\n}",
        "hints": "Heap size k, always pick smallest head node."
    },
    {
        "id": "java-h-5",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "java",
        "description": "Given strings s and t, return the smallest substring of s that contains all characters in t including duplicates. Use sliding window with character counts.",
        "examples": "Input: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"",
        "solution": "class Solution {\n  public String minWindow(String s, String t) {\n    Map<Character,Integer> need = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c,0)+1);\n    int required = need.size(), formed = 0;\n    Map<Character,Integer> window = new HashMap<>();\n    int l=0, r=0, bestLen=Integer.MAX_VALUE, bestL=0;\n    while (r < s.length()) {\n      char c = s.charAt(r);\n      window.put(c, window.getOrDefault(c,0)+1);\n      if (need.containsKey(c) && window.get(c).equals(need.get(c))) formed++;\n      while (l <= r && formed == required) {\n        if (r - l + 1 < bestLen) { bestLen = r-l+1; bestL = l; }\n        char left = s.charAt(l);\n        window.put(left, window.get(left)-1);\n        if (need.containsKey(left) && window.get(left) < need.get(left)) formed--;\n        l++;\n      }\n      r++;\n    }\n    return bestLen == Integer.MAX_VALUE ? \"\" : s.substring(bestL, bestL+bestLen);\n  }\n}",
        "hints": "Expand window to satisfy requirement; contract to minimize."
    },
    {
        "id": "java-h-6",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "language": "java",
        "description": "Given beginWord, endWord and a dictionary, return the length of shortest transformation sequence. Use BFS + generic intermediate-word patterns.",
        "examples": "Input: hit → cog\nOutput: 5",
        "solution": "class Solution {\n  public int ladderLength(String begin, String end, List<String> list) {\n    Set<String> dict = new HashSet<>(list);\n    if (!dict.contains(end)) return 0;\n    Map<String,List<String>> map = new HashMap<>();\n    int L = begin.length();\n    for (String w : dict) {\n      for (int i=0;i<L;i++){\n        String key = w.substring(0,i) + '*' + w.substring(i+1);\n        map.computeIfAbsent(key,k->new ArrayList<>()).add(w);\n      }\n    }\n    Queue<Pair<String,Integer>> q = new LinkedList<>();\n    q.add(new Pair<>(begin,1));\n    Set<String> visited = new HashSet<>(); visited.add(begin);\n    while (!q.isEmpty()){\n      Pair<String,Integer> p = q.poll();\n      String word = p.getKey(); int lvl=p.getValue();\n      for (int i=0;i<L;i++){\n        String key = word.substring(0,i)+'*'+word.substring(i+1);\n        for (String nxt : map.getOrDefault(key,Collections.emptyList())){\n          if (nxt.equals(end)) return lvl+1;\n          if (!visited.contains(nxt)){\n            visited.add(nxt);\n            q.add(new Pair<>(nxt,lvl+1));\n          }\n        }\n      }\n    }\n    return 0;\n  }\n}",
        "hints": "Precompute wildcard patterns, BFS for shortest path."
    },
    {
        "id": "java-h-7",
        "title": "N-Queens",
        "difficulty": "Hard",
        "language": "java",
        "description": "Place n queens on n×n chessboard so that no queens attack each other. Return all solutions.",
        "examples": "n = 4 → 2 solutions",
        "solution": "class Solution {\n  List<List<String>> res = new ArrayList<>();\n  public List<List<String>> solveNQueens(int n) {\n    char[][] board = new char[n][n];\n    for (char[] row : board) Arrays.fill(row, '.');\n    backtrack(board,0,new HashSet<>(),new HashSet<>(),new HashSet<>());\n    return res;\n  }\n  private void backtrack(char[][] b,int r,Set<Integer> cols,Set<Integer> pos,Set<Integer> neg){\n    int n = b.length;\n    if(r==n){ res.add(convert(b)); return; }\n    for(int c=0;c<n;c++){\n      if(cols.contains(c)||pos.contains(r+c)||neg.contains(r-c)) continue;\n      cols.add(c); pos.add(r+c); neg.add(r-c);\n      b[r][c]='Q';\n      backtrack(b,r+1,cols,pos,neg);\n      b[r][c]='.';\n      cols.remove(c); pos.remove(r+c); neg.remove(r-c);\n    }\n  }\n  private List<String> convert(char[][] b){\n    List<String> ans = new ArrayList<>();\n    for(char[] row : b) ans.add(new String(row));\n    return ans;\n  }\n}",
        "hints": "Track used columns and diagonals; backtracking by row."
    },
    {
        "id": "java-h-8",
        "title": "Longest Consecutive Sequence",
        "difficulty": "Hard",
        "language": "java",
        "description": "Find the length of the longest consecutive sequence in an unsorted array in O(n) time.",
        "examples": "Input: [100,4,200,1,3,2]\nOutput: 4",
        "solution": "class Solution {\n  public int longestConsecutive(int[] nums) {\n    Set<Integer> set = new HashSet<>();\n    for(int n:nums) set.add(n);\n    int best=0;\n    for(int n:set){\n      if(!set.contains(n-1)){\n        int cur=n,len=1;\n        while(set.contains(cur+1)){ cur++; len++; }\n        best=Math.max(best,len);\n      }\n    }\n    return best;\n  }\n}",
        "hints": "Only start counting when n-1 not present to ensure O(n)."
    },
    {
        "id": "java-h-9",
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "language": "java",
        "description": "Design methods to serialize a binary tree into a string and deserialize it back. Use BFS with null markers.",
        "examples": "Input: [1,2,3,null,null,4,5]\nOutput: same tree after deserialization",
        "solution": "class Codec {\n  public String serialize(TreeNode root) {\n    if(root==null) return \"#\";\n    StringBuilder sb=new StringBuilder();\n    Queue<TreeNode> q=new LinkedList<>(); q.add(root);\n    while(!q.isEmpty()){\n      TreeNode n=q.poll();\n      if(n==null) sb.append(\"#, \");\n      else{\n        sb.append(n.val+\", \");\n        q.add(n.left); q.add(n.right);\n      }\n    }\n    return sb.toString();\n  }\n  public TreeNode deserialize(String data) {\n    if(data.equals(\"#\")) return null;\n    String[] vals=data.split(\", \");\n    TreeNode root=new TreeNode(Integer.parseInt(vals[0]));\n    Queue<TreeNode> q=new LinkedList<>(); q.add(root);\n    int i=1;\n    while(!q.isEmpty() && i<vals.length){\n      TreeNode n=q.poll();\n      if(!vals[i].equals(\"#\")){\n        n.left=new TreeNode(Integer.parseInt(vals[i]));\n        q.add(n.left);\n      } i++;\n      if(i<vals.length && !vals[i].equals(\"#\")){\n        n.right=new TreeNode(Integer.parseInt(vals[i]));\n        q.add(n.right);\n      } i++;\n    }\n    return root;\n  }\n}",
        "hints": "Level-order with '#' as null placeholder."
    },
    {
        "id": "java-h-10",
        "title": "Minimum Cost to Connect All Points (Prim MST)",
        "difficulty": "Hard",
        "language": "java",
        "description": "Given n points in 2D space, return the minimum cost to connect all points using Manhattan distance. Build an MST using Prim's algorithm.",
        "examples": "Input: [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20",
        "solution": "class Solution {\n  public int minCostConnectPoints(int[][] p) {\n    int n=p.length;\n    boolean[] used=new boolean[n];\n    int[] minD=new int[n]; Arrays.fill(minD,Integer.MAX_VALUE);\n    minD[0]=0;\n    int res=0;\n    for(int i=0;i<n;i++){\n      int u=-1;\n      for(int j=0;j<n;j++)\n        if(!used[j] && (u==-1 || minD[j]<minD[u])) u=j;\n      used[u]=true; res+=minD[u];\n      for(int v=0; v<n; v++){\n        int d=Math.abs(p[u][0]-p[v][0]) + Math.abs(p[u][1]-p[v][1]);\n        if(!used[v] && d<minD[v]) minD[v]=d;\n      }\n    }\n    return res;\n  }\n}",
        "hints": "Classic O(n²) Prim’s algorithm with Manhattan distances computed on the fly."
    }
]