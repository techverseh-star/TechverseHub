[
    {
        "id": "js-h-1",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "You are given an array of k sorted linked lists. Merge all lists into one sorted list and return it. Use a min-heap for O(N log k).",
        "examples": "Input: [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
        "solution": "var mergeKLists = function(lists) {\n  const heap = new MinPriorityQueue({priority: x => x.val});\n  for (let node of lists) if (node) heap.enqueue(node);\n  const dummy = {val:0,next:null};\n  let cur = dummy;\n  while (!heap.isEmpty()) {\n    let n = heap.dequeue().element;\n    cur.next = n;\n    cur = cur.next;\n    if (n.next) heap.enqueue(n.next);\n  }\n  return dummy.next;\n};",
        "hints": "Use a priority queue to always take the smallest node among lists."
    },
    {
        "id": "js-h-2",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Given an array representing elevation, compute how much water is trapped after raining using the two-pointer technique.",
        "examples": "Input: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6",
        "solution": "var trap = function(h) {\n  let l=0, r=h.length-1;\n  let leftMax=0, rightMax=0, ans=0;\n  while(l<r){\n    if(h[l]<h[r]){\n      if(h[l]>=leftMax) leftMax=h[l];\n      else ans+=leftMax-h[l];\n      l++;\n    } else {\n      if(h[r]>=rightMax) rightMax=h[r];\n      else ans+=rightMax-h[r];\n      r--;\n    }\n  }\n  return ans;\n};",
        "hints": "Move pointer from the shorter side inward."
    },
    {
        "id": "js-h-3",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Find the smallest substring of s that contains all characters of t. Use sliding window with frequency maps.",
        "examples": "s = \"ADOBECODEBANC\", t = \"ABC\" → \"BANC\"",
        "solution": "var minWindow = function(s,t){\n  const need = new Map();\n  for(let c of t) need.set(c,(need.get(c)||0)+1);\n  let have=0, needCount=need.size;\n  const window=new Map();\n  let l=0, res=[0,Infinity];\n  for(let r=0;r<s.length;r++){\n    let c=s[r];\n    window.set(c,(window.get(c)||0)+1);\n    if(need.has(c) && window.get(c)===need.get(c)) have++;\n    while(have===needCount){\n      if(r-l+1 < res[1]-res[0]) res=[l,r];\n      let lc=s[l];\n      window.set(lc,window.get(lc)-1);\n      if(need.has(lc) && window.get(lc)<need.get(lc)) have--;\n      l++;\n    }\n  }\n  return res[1]===Infinity ? \"\" : s.slice(res[0],res[1]+1);\n};",
        "hints": "Track how many required characters are satisfied."
    },
    {
        "id": "js-h-4",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Return the shortest transformation from beginWord to endWord using BFS and wildcard pattern graph.",
        "examples": "hit → cog, words=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] → 5",
        "solution": "var ladderLength=function(begin,end,list){\n  const dict=new Set(list);\n  if(!dict.has(end)) return 0;\n  const map={};\n  const L=begin.length;\n  for(let w of dict)\n    for(let i=0;i<L;i++){\n      const key=w.slice(0,i)+'*'+w.slice(i+1);\n      (map[key] ||= []).push(w);\n    }\n  const q=[[begin,1]];\n  const seen=new Set([begin]);\n  while(q.length){\n    const [word,step]=q.shift();\n    if(word===end) return step;\n    for(let i=0;i<L;i++){\n      const key=word.slice(0,i)+'*'+word.slice(i+1);\n      for(let nxt of map[key]||[]){\n        if(!seen.has(nxt)){\n          seen.add(nxt);\n          q.push([nxt,step+1]);\n        }\n      }\n    }\n  }\n  return 0;\n};",
        "hints": "Use BFS on wildcard adjacency graph."
    },
    {
        "id": "js-h-5",
        "title": "N-Queens",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Place n queens on a chessboard so none attack each other. Return all solutions.",
        "examples": "n=4 → 2 solutions",
        "solution": "var solveNQueens=function(n){\n  const res=[];\n  const board=Array.from({length:n},()=>Array(n).fill('.'));\n  const cols=new Set(), pos=new Set(), neg=new Set();\n  const backtrack=(r)=>{\n    if(r===n){ res.push(board.map(row=>row.join(''))); return; }\n    for(let c=0;c<n;c++){\n      if(cols.has(c)||pos.has(r+c)||neg.has(r-c)) continue;\n      cols.add(c); pos.add(r+c); neg.add(r-c);\n      board[r][c]='Q';\n      backtrack(r+1);\n      board[r][c]='.';\n      cols.delete(c); pos.delete(r+c); neg.delete(r-c);\n    }\n  };\n  backtrack(0);\n  return res;\n};",
        "hints": "Track columns and diagonals sets for pruning."
    },
    {
        "id": "js-h-6",
        "title": "Serialize & Deserialize Binary Tree",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Implement methods serialize() and deserialize() using BFS and null markers.",
        "examples": "Input: [1,2,3,null,null,4,5]",
        "solution": "var serialize=function(root){\n  if(!root) return '#';\n  const q=[root], res=[];\n  while(q.length){\n    const n=q.shift();\n    if(!n){ res.push('#'); continue; }\n    res.push(n.val);\n    q.push(n.left); q.push(n.right);\n  }\n  return res.join(',');\n};\n\nvar deserialize=function(data){\n  if(data==='#') return null;\n  const vals=data.split(',');\n  const root={val:+vals[0],left:null,right:null};\n  const q=[root];\n  let i=1;\n  while(q.length && i<vals.length){\n    const n=q.shift();\n    if(vals[i] !== '#'){ n.left={val:+vals[i],left:null,right:null}; q.push(n.left);} i++;\n    if(vals[i] !== '#'){ n.right={val:+vals[i],left:null,right:null}; q.push(n.right);} i++;\n  }\n  return root;\n};",
        "hints": "Use level-order traversal with '#' for null."
    },
    {
        "id": "js-h-7",
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Given a string of parentheses, find the length of the longest valid substring.",
        "examples": "Input: \"(()\"\nOutput: 2",
        "solution": "var longestValidParentheses=function(s){\n  let max=0;\n  const stack=[-1];\n  for(let i=0;i<s.length;i++){\n    if(s[i]==='(') stack.push(i);\n    else {\n      stack.pop();\n      if(!stack.length) stack.push(i);\n      else max=Math.max(max, i-stack[stack.length-1]);\n    }\n  }\n  return max;\n};",
        "hints": "Use stack with base index."
    },
    {
        "id": "js-h-8",
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Maximize coins by bursting balloons in optimal order. Use DP on intervals.",
        "examples": "Input: [3,1,5,8]\nOutput: 167",
        "solution": "var maxCoins=function(nums){\n  nums=[1,...nums,1];\n  let n=nums.length;\n  const dp=[...Array(n)].map(()=>Array(n).fill(0));\n  for(let len=2; len<n; len++){\n    for(let l=0; l+len<n; l++){\n      const r=l+len;\n      for(let k=l+1; k<r; k++){\n        dp[l][r]=Math.max(dp[l][r],nums[l]*nums[k]*nums[r]+dp[l][k]+dp[k][r]);\n      }\n    }\n  }\n  return dp[0][n-1];\n};",
        "hints": "Try bursting balloon k last in interval (l, r)."
    },
    {
        "id": "js-h-9",
        "title": "Alien Dictionary (Topological Sort)",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Given sorted alien language words, return character order using graph + topological sorting.",
        "examples": "Input: [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\nOutput: \"wertf\"",
        "solution": "var alienOrder=function(words){\n  const graph=new Map();\n  const indeg=new Map();\n  for(let w of words) for(let c of w){ graph.set(c,[]); indeg.set(c,0); }\n  for(let i=0;i<words.length-1;i++){\n    const w1=words[i], w2=words[i+1];\n    if(w1.startsWith(w2) && w1.length>w2.length) return \"\";\n    for(let j=0;j<Math.min(w1.length,w2.length);j++){\n      if(w1[j]!==w2[j]){\n        graph.get(w1[j]).push(w2[j]);\n        indeg.set(w2[j], indeg.get(w2[j])+1);\n        break;\n      }\n    }\n  }\n  const q=[...indeg.entries()].filter(([k,v])=>v===0).map(([k])=>k);\n  const res=[];\n  while(q.length){\n    const c=q.shift(); res.push(c);\n    for(let n of graph.get(c)){\n      indeg.set(n,indeg.get(n)-1);\n      if(indeg.get(n)===0) q.push(n);\n    }\n  }\n  return res.length===indeg.size ? res.join('') : \"\";\n};",
        "hints": "Build graph from lexicographical differences."
    },
    {
        "id": "js-h-10",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "language": "javascript",
        "description": "Implement regex matching with '.' and '*'. Use DP table dp[i][j]=match(s[0..i),p[0..j)).",
        "examples": "Input: s=\"aab\", p=\"c*a*b\" → true",
        "solution": "var isMatch=function(s,p){\n  const dp=[...Array(s.length+1)].map(()=>Array(p.length+1).fill(false));\n  dp[0][0]=true;\n  for(let j=2;j<=p.length;j++) if(p[j-1]==='*') dp[0][j]=dp[0][j-2];\n  for(let i=1;i<=s.length;i++){\n    for(let j=1;j<=p.length;j++){\n      if(p[j-1]==='.' || p[j-1]===s[i-1]) dp[i][j]=dp[i-1][j-1];\n      else if(p[j-1]==='*'){\n        dp[i][j]=dp[i][j-2];\n        if(p[j-2]==='.' || p[j-2]===s[i-1]) dp[i][j] ||= dp[i-1][j];\n      }\n    }\n  }\n  return dp[s.length][p.length];\n};",
        "hints": "DP handles '*': zero or multiple char consumption."
    }
]