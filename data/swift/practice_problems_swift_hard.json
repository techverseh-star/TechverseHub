[
    {
        "id": "swift-h-1",
        "title": "Longest Palindromic Substring",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Given a string s, return the longest palindromic substring. Use expand-around-center algorithm for O(n²) time.",
        "examples": "\"babad\" → \"bab\" or \"aba\"",
        "solution": "func longestPalindrome(_ s: String) -> String {\n    let chars = Array(s)\n    var start = 0, end = 0\n    func expand(_ left: Int, _ right: Int) -> (Int, Int) {\n        var l = left, r = right\n        while l >= 0 && r < chars.count && chars[l] == chars[r] {\n            l -= 1; r += 1\n        }\n        return (l+1, r-1)\n    }\n    for i in 0..<chars.count {\n        let (l1, r1) = expand(i, i)\n        if r1 - l1 > end - start {\n            start = l1; end = r1\n        }\n        let (l2, r2) = expand(i, i+1)\n        if r2 - l2 > end - start {\n            start = l2; end = r2\n        }\n    }\n    return String(chars[start...end])\n}",
        "hints": "Try expanding from each center index."
    },
    {
        "id": "swift-h-2",
        "title": "LRU Cache Implementation",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Implement an LRU cache class with get(key) and put(key, value). Both must run in O(1) time using dictionary + doubly linked list.",
        "examples": "cache.put(1,1) → cache.get(1) returns 1",
        "solution": "class LRUCache {\n    class Node {\n        var key: Int\n        var value: Int\n        var prev: Node?\n        var next: Node?\n        init(_ key: Int, _ value: Int) { self.key = key; self.value = value }\n    }\n    var dict = [Int:Node]()\n    let capacity: Int\n    var head = Node(0,0)\n    var tail = Node(0,0)\n    init(_ capacity: Int) {\n        self.capacity = capacity\n        head.next = tail; tail.prev = head\n    }\n    func remove(_ n: Node) {\n        n.prev?.next = n.next\n        n.next?.prev = n.prev\n    }\n    func insert(_ n: Node) {\n        n.next = head.next\n        n.prev = head\n        head.next?.prev = n\n        head.next = n\n    }\n    func get(_ key: Int) -> Int {\n        if let node = dict[key] {\n            remove(node); insert(node)\n            return node.value\n        }\n        return -1\n    }\n    func put(_ key: Int, _ value: Int) {\n        if let node = dict[key] {\n            node.value = value\n            remove(node); insert(node)\n        } else {\n            let node = Node(key, value)\n            dict[key] = node\n            insert(node)\n            if dict.count > capacity {\n                let del = tail.prev!\n                remove(del)\n                dict.removeValue(forKey: del.key)\n            }\n        }\n    }\n}",
        "hints": "Use dictionary as O(1) lookup and linked list for ordering."
    },
    {
        "id": "swift-h-3",
        "title": "Word Break (DP)",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Return true if string s can be segmented into dictionary words. Use dynamic programming.",
        "examples": "\"leetcode\", [\"leet\",\"code\"] → true",
        "solution": "func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\n    let n = s.count\n    let chars = Array(s)\n    let dict = Set(wordDict)\n    var dp = Array(repeating: false, count: n+1)\n    dp[0] = true\n    for i in 1...n {\n        for j in 0..<i {\n            if dp[j] && dict.contains(String(chars[j..<i])) {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[n]\n}",
        "hints": "Use dp[i] meaning prefix length i is valid."
    },
    {
        "id": "swift-h-4",
        "title": "Generate All Subsets",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Generate the power set of an array using recursion.",
        "examples": "[1,2] → [[],[1],[2],[1,2]]",
        "solution": "func subsets(_ nums: [Int]) -> [[Int]] {\n    var res: [[Int]] = []\n    var cur: [Int] = []\n    func backtrack(_ index: Int) {\n        if index == nums.count {\n            res.append(cur)\n            return\n        }\n        backtrack(index+1)\n        cur.append(nums[index])\n        backtrack(index+1)\n        cur.removeLast()\n    }\n    backtrack(0)\n    return res\n}",
        "hints": "Recursive include/exclude pattern."
    },
    {
        "id": "swift-h-5",
        "title": "Find Kth Largest Element",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Use Quickselect algorithm to find kth largest element in array.",
        "examples": "[3,2,1,5,6,4], k = 2 → 5",
        "solution": "func findKthLargest(_ nums: inout [Int], _ k: Int) -> Int {\n    let target = nums.count - k\n    func partition(_ l: Int, _ r: Int) -> Int {\n        let pivot = nums[r]\n        var i = l\n        for j in l..<r {\n            if nums[j] <= pivot {\n                nums.swapAt(i, j); i += 1\n            }\n        }\n        nums.swapAt(i, r)\n        return i\n    }\n    var l = 0, r = nums.count-1\n    while true {\n        let p = partition(l, r)\n        if p == target { return nums[p] }\n        else if p < target { l = p + 1 }\n        else { r = p - 1 }\n    }\n}",
        "hints": "Quickselect = partition until pivot equals target index."
    },
    {
        "id": "swift-h-6",
        "title": "Group Anagrams",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Group words that are anagrams using dictionary with sorted-string keys.",
        "examples": "[\"eat\",\"tea\",\"ate\"] → [[\"eat\",\"tea\",\"ate\"]]",
        "solution": "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var map: [String:[String]] = [:]\n    for word in strs {\n        let key = String(word.sorted())\n        map[key, default: []].append(word)\n    }\n    return Array(map.values)\n}",
        "hints": "Sorting characters creates identical keys."
    },
    {
        "id": "swift-h-7",
        "title": "Longest Consecutive Sequence",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Given unsorted array, return length of longest consecutive sequence using a Set. O(n) time.",
        "examples": "[100,4,200,1,3,2] → 4",
        "solution": "func longestConsecutive(_ nums: [Int]) -> Int {\n    let setNums = Set(nums)\n    var longest = 0\n    for n in setNums {\n        if !setNums.contains(n-1) {\n            var cur = n\n            var len = 1\n            while setNums.contains(cur+1) {\n                cur += 1; len += 1\n            }\n            longest = max(longest, len)\n        }\n    }\n    return longest\n}",
        "hints": "Start counting only from sequence starting points."
    },
    {
        "id": "swift-h-8",
        "title": "Find All Permutations",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Generate all permutations of array using recursion.",
        "examples": "[1,2] → [[1,2],[2,1]]",
        "solution": "func permute(_ nums: [Int]) -> [[Int]] {\n    var res: [[Int]] = []\n    var nums = nums\n    func backtrack(_ i: Int) {\n        if i == nums.count {\n            res.append(nums)\n            return\n        }\n        for j in i..<nums.count {\n            nums.swapAt(i, j)\n            backtrack(i+1)\n            nums.swapAt(i, j)\n        }\n    }\n    backtrack(0)\n    return res\n}",
        "hints": "Swap-based permutation generation."
    },
    {
        "id": "swift-h-9",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Return the smallest substring of s that contains all characters of t using sliding window.",
        "examples": "s=\"ADOBECODEBANC\", t=\"ABC\" → \"BANC\"",
        "solution": "func minWindow(_ s: String, _ t: String) -> String {\n    let sArr = Array(s), tArr = Array(t)\n    var need: [Character:Int] = [:]\n    var have: [Character:Int] = [:]\n    for c in tArr { need[c, default:0] += 1 }\n    var required = need.count, formed = 0\n    var l = 0, r = 0\n    var ans = (len: Int.max, l: 0, r: 0)\n    while r < sArr.count {\n        let c = sArr[r]\n        have[c, default:0] += 1\n        if let n = need[c], have[c] == n { formed += 1 }\n        while l <= r && formed == required {\n            if r - l + 1 < ans.len {\n                ans = (r-l+1, l, r)\n            }\n            let lc = sArr[l]\n            have[lc]! -= 1\n            if let n = need[lc], have[lc]! < n { formed -= 1 }\n            l += 1\n        }\n        r += 1\n    }\n    return ans.len == Int.max ? \"\" : String(sArr[ans.l...ans.r])\n}",
        "hints": "Maintain window counts and shrink when valid."
    },
    {
        "id": "swift-h-10",
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Hard",
        "language": "swift",
        "description": "Evaluate an RPN expression using a stack. Tokens may be '+', '-', '*', '/' or integers.",
        "examples": "[\"2\",\"1\",\"+\",\"3\",\"*\"] → 9",
        "solution": "func evalRPN(_ tokens: [String]) -> Int {\n    var stack = [Int]()\n    for t in tokens {\n        if let n = Int(t) { stack.append(n) }\n        else {\n            let b = stack.removeLast()\n            let a = stack.removeLast()\n            switch t {\n                case \"+\": stack.append(a+b)\n                case \"-\": stack.append(a-b)\n                case \"*\": stack.append(a*b)\n                case \"/\": stack.append(a/b)\n                default: break\n            }\n        }\n    }\n    return stack.last!\n}",
        "hints": "Use stack.pop() for operands."
    }
]