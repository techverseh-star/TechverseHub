[
  {
    "id": "1",
    "title": "Two Sum",
    "difficulty": "Easy",
    "language": "javascript",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "examples": "Example 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]",
    "solution": "function solution(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}",
    "hints": "Try using a hash map to store numbers you've seen before. For each number, check if its complement (target - number) exists in the map."
  },
  {
    "id": "2",
    "title": "Reverse String",
    "difficulty": "Easy",
    "language": "python",
    "description": "Write a function that reverses a string. The input string is given as an array of characters.",
    "examples": "Example 1:\nInput: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']\n\nExample 2:\nInput: s = ['H','a','n','n','a','h']\nOutput: ['h','a','n','n','a','H']",
    "solution": "def solution(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s",
    "hints": "Use two pointers approach - one at the start and one at the end. Swap characters and move pointers towards center."
  },
  {
    "id": "3",
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "language": "javascript",
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise.",
    "examples": "Example 1:\nInput: x = 121\nOutput: true\n\nExample 2:\nInput: x = -121\nOutput: false",
    "solution": "function solution(x) {\n  if (x < 0) return false;\n  const str = x.toString();\n  return str === str.split('').reverse().join('');\n}",
    "hints": "Convert the number to a string and check if it reads the same forwards and backwards."
  },
  {
    "id": "4",
    "title": "FizzBuzz",
    "difficulty": "Easy",
    "language": "python",
    "description": "Given an integer n, return a string array answer where:\n- answer[i] == 'FizzBuzz' if i is divisible by 3 and 5\n- answer[i] == 'Fizz' if i is divisible by 3\n- answer[i] == 'Buzz' if i is divisible by 5\n- answer[i] == str(i) if none of the above conditions are true",
    "examples": "Example 1:\nInput: n = 5\nOutput: ['1','2','Fizz','4','Buzz']",
    "solution": "def solution(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(str(i))\n    return result",
    "hints": "Check divisibility by 15 first (both 3 and 5), then check 3, then 5."
  },
  {
    "id": "5",
    "title": "Maximum Subarray",
    "difficulty": "Easy",
    "language": "javascript",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "examples": "Example 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6",
    "solution": "function solution(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}",
    "hints": "Use Kadane's algorithm. Keep track of the current sum and the maximum sum seen so far."
  },
  {
    "id": "6",
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "language": "python",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:\n1. Open brackets must be closed by the same type of brackets\n2. Open brackets must be closed in the correct order",
    "examples": "Example 1:\nInput: s = '()'\nOutput: true\n\nExample 2:\nInput: s = '()[]{}'\nOutput: true\n\nExample 3:\nInput: s = '(]'\nOutput: false",
    "solution": "def solution(s):\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    for char in s:\n        if char in pairs:\n            stack.append(char)\n        elif not stack or pairs[stack.pop()] != char:\n            return False\n    return len(stack) == 0",
    "hints": "Use a stack to track opening brackets. When you see a closing bracket, check if it matches the most recent opening bracket."
  },
  {
    "id": "7",
    "title": "Merge Sorted Arrays",
    "difficulty": "Easy",
    "language": "javascript",
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order. Merge nums1 and nums2 into a single array sorted in non-decreasing order.",
    "examples": "Example 1:\nInput: nums1 = [1,2,3], nums2 = [2,5,6]\nOutput: [1,2,2,3,5,6]",
    "solution": "function solution(nums1, nums2) {\n  return [...nums1, ...nums2].sort((a, b) => a - b);\n}",
    "hints": "You can use two pointers to merge the arrays, or simply concatenate and sort."
  },
  {
    "id": "8",
    "title": "Remove Duplicates",
    "difficulty": "Easy",
    "language": "python",
    "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. Return the new length.",
    "examples": "Example 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\n\nExample 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]",
    "solution": "def solution(nums):\n    if not nums:\n        return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1",
    "hints": "Use two pointers. One pointer tracks unique elements, the other scans through the array."
  },
  {
    "id": "9",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "language": "javascript",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve.",
    "examples": "Example 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5",
    "solution": "function solution(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  for (let price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n  return maxProfit;\n}",
    "hints": "Keep track of the minimum price seen so far and calculate profit at each step."
  },
  {
    "id": "10",
    "title": "Single Number",
    "difficulty": "Easy",
    "language": "python",
    "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.",
    "examples": "Example 1:\nInput: nums = [2,2,1]\nOutput: 1\n\nExample 2:\nInput: nums = [4,1,2,1,2]\nOutput: 4",
    "solution": "def solution(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result",
    "hints": "Use XOR operation. XORing a number with itself results in 0, and XORing with 0 returns the number."
  },
  {
    "id": "11",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "language": "javascript",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, find two lines that together with the x-axis form a container that contains the most water.",
    "examples": "Example 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49",
    "solution": "function solution(height) {\n  let left = 0, right = height.length - 1;\n  let maxArea = 0;\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    maxArea = Math.max(maxArea, area);\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return maxArea;\n}",
    "hints": "Use two pointers at both ends. Move the pointer with the smaller height inward."
  },
  {
    "id": "12",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "language": "python",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "examples": "Example 1:\nInput: s = 'abcabcbb'\nOutput: 3\nExplanation: The answer is 'abc', with the length of 3",
    "solution": "def solution(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "hints": "Use a sliding window with a set to track characters. Expand the window and shrink it when duplicates are found."
  },
  {
    "id": "13",
    "title": "3Sum",
    "difficulty": "Medium",
    "language": "javascript",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
    "examples": "Example 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]",
    "solution": "function solution(nums) {\n  nums.sort((a, b) => a - b);\n  const result = [];\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    let left = i + 1, right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return result;\n}",
    "hints": "Sort the array first. For each number, use two pointers to find pairs that sum to its negative."
  },
  {
    "id": "14",
    "title": "Product of Array Except Self",
    "difficulty": "Medium",
    "language": "python",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
    "examples": "Example 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
    "solution": "def solution(nums):\n    n = len(nums)\n    result = [1] * n\n    left = 1\n    for i in range(n):\n        result[i] *= left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= right\n        right *= nums[i]\n    return result",
    "hints": "Use two passes: one for left products and one for right products. Multiply them together."
  },
  {
    "id": "15",
    "title": "Group Anagrams",
    "difficulty": "Medium",
    "language": "javascript",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
    "examples": "Example 1:\nInput: strs = ['eat','tea','tan','ate','nat','bat']\nOutput: [['bat'],['nat','tan'],['ate','eat','tea']]",
    "solution": "function solution(strs) {\n  const map = new Map();\n  for (let str of strs) {\n    const key = str.split('').sort().join('');\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(str);\n  }\n  return Array.from(map.values());\n}",
    "hints": "Sort each string and use it as a key in a hash map to group anagrams."
  },
  {
    "id": "16",
    "title": "Longest Palindromic Substring",
    "difficulty": "Medium",
    "language": "python",
    "description": "Given a string s, return the longest palindromic substring in s.",
    "examples": "Example 1:\nInput: s = 'babad'\nOutput: 'bab' or 'aba'\n\nExample 2:\nInput: s = 'cbbd'\nOutput: 'bb'",
    "solution": "def solution(s):\n    def expand(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    result = ''\n    for i in range(len(s)):\n        odd = expand(i, i)\n        even = expand(i, i + 1)\n        result = max([result, odd, even], key=len)\n    return result",
    "hints": "Expand around each character (odd length) and between characters (even length) to find palindromes."
  },
  {
    "id": "17",
    "title": "Rotate Array",
    "difficulty": "Medium",
    "language": "javascript",
    "description": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
    "examples": "Example 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]",
    "solution": "function solution(nums, k) {\n  k = k % nums.length;\n  const reverse = (arr, start, end) => {\n    while (start < end) {\n      [arr[start], arr[end]] = [arr[end], arr[start]];\n      start++;\n      end--;\n    }\n  };\n  reverse(nums, 0, nums.length - 1);\n  reverse(nums, 0, k - 1);\n  reverse(nums, k, nums.length - 1);\n  return nums;\n}",
    "hints": "Reverse the entire array, then reverse the first k elements, then reverse the remaining elements."
  },
  {
    "id": "18",
    "title": "Permutations",
    "difficulty": "Medium",
    "language": "python",
    "description": "Given an array nums of distinct integers, return all the possible permutations.",
    "examples": "Example 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
    "solution": "def solution(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result",
    "hints": "Use backtracking. Add each number to the current permutation and recurse until all numbers are used."
  },
  {
    "id": "19",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "language": "javascript",
    "description": "Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
    "examples": "Example 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4",
    "solution": "function solution(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[left] <= nums[mid]) {\n      if (nums[left] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      if (nums[mid] < target && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}",
    "hints": "Use modified binary search. Determine which half is sorted and check if target is in that range."
  },
  {
    "id": "20",
    "title": "Subsets",
    "difficulty": "Medium",
    "language": "python",
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).",
    "examples": "Example 1:\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
    "solution": "def solution(nums):\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result",
    "hints": "Use backtracking. For each element, you can either include it or exclude it in the subset."
  },
  {
    "id": "21",
    "title": "Regular Expression Matching",
    "difficulty": "Hard",
    "language": "javascript",
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n'.' Matches any single character\n'*' Matches zero or more of the preceding element",
    "examples": "Example 1:\nInput: s = 'aa', p = 'a*'\nOutput: true",
    "solution": "function solution(s, p) {\n  const dp = Array(s.length + 1).fill(0).map(() => Array(p.length + 1).fill(false));\n  dp[0][0] = true;\n  for (let j = 1; j <= p.length; j++) {\n    if (p[j - 1] === '*') {\n      dp[0][j] = dp[0][j - 2];\n    }\n  }\n  for (let i = 1; i <= s.length; i++) {\n    for (let j = 1; j <= p.length; j++) {\n      if (p[j - 1] === '*') {\n        dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n      } else {\n        dp[i][j] = dp[i - 1][j - 1] && (s[i - 1] === p[j - 1] || p[j - 1] === '.');\n      }\n    }\n  }\n  return dp[s.length][p.length];\n}",
    "hints": "Use dynamic programming. Build a 2D table where dp[i][j] represents if s[0..i-1] matches p[0..j-1]."
  },
  {
    "id": "22",
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "language": "python",
    "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "examples": "Example 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
    "solution": "def solution(lists):\n    import heapq\n    heap = []\n    result = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        if elem_idx + 1 < len(lists[list_idx]):\n            heapq.heappush(heap, (lists[list_idx][elem_idx + 1], list_idx, elem_idx + 1))\n    return result",
    "hints": "Use a min heap to track the smallest element from each list. Always pop the smallest and add the next element from that list."
  },
  {
    "id": "23",
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "language": "javascript",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "examples": "Example 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6",
    "solution": "function solution(height) {\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0;\n  let water = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        water += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        water += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  return water;\n}",
    "hints": "Use two pointers. Track the maximum height from both sides and calculate trapped water based on the smaller maximum."
  },
  {
    "id": "24",
    "title": "Median of Two Sorted Arrays",
    "difficulty": "Hard",
    "language": "python",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
    "examples": "Example 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.0",
    "solution": "def solution(nums1, nums2):\n    merged = sorted(nums1 + nums2)\n    n = len(merged)\n    if n % 2 == 0:\n        return (merged[n // 2 - 1] + merged[n // 2]) / 2\n    return float(merged[n // 2])",
    "hints": "Merge the two arrays and find the median. For optimization, use binary search."
  },
  {
    "id": "25",
    "title": "Word Ladder",
    "difficulty": "Hard",
    "language": "javascript",
    "description": "Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "examples": "Example 1:\nInput: beginWord = 'hit', endWord = 'cog', wordList = ['hot','dot','dog','lot','log','cog']\nOutput: 5",
    "solution": "function solution(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  const queue = [[beginWord, 1]];\n  while (queue.length) {\n    const [word, level] = queue.shift();\n    if (word === endWord) return level;\n    for (let i = 0; i < word.length; i++) {\n      for (let c = 97; c <= 122; c++) {\n        const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);\n        if (wordSet.has(newWord)) {\n          queue.push([newWord, level + 1]);\n          wordSet.delete(newWord);\n        }\n      }\n    }\n  }\n  return 0;\n}",
    "hints": "Use BFS. For each word, try changing each character and check if the new word is in the dictionary."
  },
  {
    "id": "26",
    "title": "Longest Consecutive Sequence",
    "difficulty": "Hard",
    "language": "python",
    "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
    "examples": "Example 1:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive sequence is [1,2,3,4]",
    "solution": "def solution(nums):\n    num_set = set(nums)\n    longest = 0\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n            longest = max(longest, current_streak)\n    return longest",
    "hints": "Use a set for O(1) lookup. For each number, check if it's the start of a sequence and count consecutive numbers."
  },
  {
    "id": "27",
    "title": "Edit Distance",
    "difficulty": "Hard",
    "language": "javascript",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert, Delete, Replace a character.",
    "examples": "Example 1:\nInput: word1 = 'horse', word2 = 'ros'\nOutput: 3",
    "solution": "function solution(word1, word2) {\n  const m = word1.length, n = word2.length;\n  const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n      }\n    }\n  }\n  return dp[m][n];\n}",
    "hints": "Use dynamic programming. dp[i][j] represents the edit distance between word1[0..i-1] and word2[0..j-1]."
  },
  {
    "id": "28",
    "title": "N-Queens",
    "difficulty": "Hard",
    "language": "python",
    "description": "The n-queens puzzle is the problem of placing n queens on an nÃ—n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle.",
    "examples": "Example 1:\nInput: n = 4\nOutput: [['.Q..','...Q','Q...','..Q.'],['..Q.','Q...','...Q','.Q..']]",
    "solution": "def solution(n):\n    result = []\n    def backtrack(row, cols, diag1, diag2, board):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if col in cols or row - col in diag1 or row + col in diag2:\n                continue\n            board[row][col] = 'Q'\n            backtrack(row + 1, cols | {col}, diag1 | {row - col}, diag2 | {row + col}, board)\n            board[row][col] = '.'\n    backtrack(0, set(), set(), set(), [['.' for _ in range(n)] for _ in range(n)])\n    return result",
    "hints": "Use backtracking with sets to track occupied columns and diagonals. For each row, try placing a queen in each valid column."
  },
  {
    "id": "29",
    "title": "Word Break II",
    "difficulty": "Hard",
    "language": "javascript",
    "description": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.",
    "examples": "Example 1:\nInput: s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']\nOutput: ['cats and dog','cat sand dog']",
    "solution": "function solution(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const memo = new Map();\n  function backtrack(start) {\n    if (memo.has(start)) return memo.get(start);\n    if (start === s.length) return [[]];\n    const result = [];\n    for (let end = start + 1; end <= s.length; end++) {\n      const word = s.slice(start, end);\n      if (wordSet.has(word)) {\n        const rest = backtrack(end);\n        for (let sentence of rest) {\n          result.push([word, ...sentence]);\n        }\n      }\n    }\n    memo.set(start, result);\n    return result;\n  }\n  return backtrack(0).map(words => words.join(' '));\n}",
    "hints": "Use backtracking with memoization. For each position, try all possible words that start from that position."
  },
  {
    "id": "30",
    "title": "Maximum Profit in Job Scheduling",
    "difficulty": "Hard",
    "language": "python",
    "description": "We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i]. You're given the arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.",
    "examples": "Example 1:\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\nOutput: 120",
    "solution": "def solution(startTime, endTime, profit):\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [[0, 0]]\n    for s, e, p in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]",
    "hints": "Sort jobs by end time. Use dynamic programming to track maximum profit at each job, considering whether to include or exclude it."
  }
]
