[
    {
        "id": "dart-h-1",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Given a string s, return the length of the longest substring without repeating characters using sliding window.",
        "examples": "\"abcabcbb\" → 3",
        "solution": "int lengthOfLongestSubstring(String s) {\n  Set<String> set = {};\n  int left = 0, maxLen = 0;\n  for (int right = 0; right < s.length; right++) {\n    while (set.contains(s[right])) {\n      set.remove(s[left]);\n      left++;\n    }\n    set.add(s[right]);\n    maxLen = maxLen < right - left + 1 ? right - left + 1 : maxLen;\n  }\n  return maxLen;\n}",
        "hints": "Sliding window + Set."
    },
    {
        "id": "dart-h-2",
        "title": "Word Break (DP)",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Return true if string s can be segmented into dictionary words.",
        "examples": "\"leetcode\", [\"leet\",\"code\"] → true",
        "solution": "bool wordBreak(String s, List<String> wordDict) {\n  Set<String> dict = wordDict.toSet();\n  List<bool> dp = List.filled(s.length + 1, false);\n  dp[0] = true;\n  for (int i = 1; i <= s.length; i++) {\n    for (int j = 0; j < i; j++) {\n      if (dp[j] && dict.contains(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  return dp[s.length];\n}",
        "hints": "dp[i] = true if prefix can be segmented."
    },
    {
        "id": "dart-h-3",
        "title": "Generate All Subsets",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Generate the power set of a list using backtracking.",
        "examples": "[1,2] → [[],[1],[2],[1,2]]",
        "solution": "List<List<int>> subsets(List<int> nums) {\n  List<List<int>> res = [];\n  List<int> cur = [];\n  void backtrack(int i) {\n    if (i == nums.length) {\n      res.add(List.from(cur));\n      return;\n    }\n    backtrack(i + 1);\n    cur.add(nums[i]);\n    backtrack(i + 1);\n    cur.removeLast();\n  }\n  backtrack(0);\n  return res;\n}",
        "hints": "Include/exclude recursion."
    },
    {
        "id": "dart-h-4",
        "title": "Permutations",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Generate all permutations of the list nums.",
        "examples": "[1,2] → [[1,2],[2,1]]",
        "solution": "List<List<int>> permute(List<int> nums) {\n  List<List<int>> res = [];\n  void backtrack(int i) {\n    if (i == nums.length) {\n      res.add(List.from(nums));\n      return;\n    }\n    for (int j = i; j < nums.length; j++) {\n      int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;\n      backtrack(i + 1);\n      temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;\n    }\n  }\n  backtrack(0);\n  return res;\n}",
        "hints": "Swap-based backtracking."
    },
    {
        "id": "dart-h-5",
        "title": "Top K Frequent Elements",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Return the k most frequent elements from a list.",
        "examples": "[1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "List<int> topKFrequent(List<int> nums, int k) {\n  Map<int,int> freq = {};\n  for (var n in nums) freq[n] = (freq[n] ?? 0) + 1;\n  var sorted = freq.entries.toList()\n    ..sort((a,b)=>b.value.compareTo(a.value));\n  return sorted.take(k).map((e)=>e.key).toList();\n}",
        "hints": "Use frequency map + sorting."
    },
    {
        "id": "dart-h-6",
        "title": "Kth Largest Element (Quickselect)",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Find the kth largest element using Quickselect.",
        "examples": "[3,2,1,5,6,4], k=2 → 5",
        "solution": "int findKthLargest(List<int> nums, int k) {\n  int target = nums.length - k;\n  int partition(int l, int r) {\n    int pivot = nums[r];\n    int i = l;\n    for (int j = l; j < r; j++) {\n      if (nums[j] <= pivot) {\n        int t = nums[i]; nums[i] = nums[j]; nums[j] = t;\n        i++;\n      }\n    }\n    int t = nums[i]; nums[i] = nums[r]; nums[r] = t;\n    return i;\n  }\n  int l = 0, r = nums.length - 1;\n  while (true) {\n    int p = partition(l, r);\n    if (p == target) return nums[p];\n    else if (p < target) l = p + 1;\n    else r = p - 1;\n  }\n}",
        "hints": "Partition until pivot index matches target."
    },
    {
        "id": "dart-h-7",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Return the minimum window substring of s that contains all characters of t.",
        "examples": "\"ADOBECODEBANC\", \"ABC\" → \"BANC\"",
        "solution": "String minWindow(String s, String t) {\n  if (t.isEmpty) return '';\n  Map<String,int> need = {};\n  for (var c in t.split('')) need[c] = (need[c] ?? 0) + 1;\n  Map<String,int> have = {};\n  int haveCount = 0;\n  int left = 0;\n  int minLen = 1<<30;\n  String res = '';\n  for (int right = 0; right < s.length; right++) {\n    String c = s[right];\n    have[c] = (have[c] ?? 0) + 1;\n    if (need.containsKey(c) && have[c] == need[c]) haveCount++;\n\n    while (haveCount == need.length) {\n      if (right - left + 1 < minLen) {\n        minLen = right - left + 1;\n        res = s.substring(left, right + 1);\n      }\n      String lc = s[left];\n      have[lc] = have[lc]! - 1;\n      if (need.containsKey(lc) && have[lc]! < need[lc]!) haveCount--;\n      left++;\n    }\n  }\n  return res;\n}",
        "hints": "Sliding window with frequency tracking."
    },
    {
        "id": "dart-h-8",
        "title": "Number of Islands",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Count the number of islands in a 2D grid using DFS.",
        "examples": "[[1,1,0],[0,1,0]] → 1",
        "solution": "int numIslands(List<List<int>> grid) {\n  int rows = grid.length, cols = grid[0].length;\n  int count = 0;\n\n  void dfs(int r, int c) {\n    if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] == 0) return;\n    grid[r][c] = 0;\n    dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1);\n  }\n\n  for (int r = 0; r < rows; r++) {\n    for (int c = 0; c < cols; c++) {\n      if (grid[r][c] == 1) {\n        count++;\n        dfs(r, c);\n      }\n    }\n  }\n  return count;\n}",
        "hints": "DFS flood fill."
    },
    {
        "id": "dart-h-9",
        "title": "Group Anagrams",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Group strings that are anagrams using sorted character keys.",
        "examples": "[\"eat\",\"tea\",\"ate\"] → [[\"eat\",\"tea\",\"ate\"]]",
        "solution": "List<List<String>> groupAnagrams(List<String> strs) {\n  Map<String,List<String>> map = {};\n  for (var s in strs) {\n    String key = (s.split('')..sort()).join();\n    map.putIfAbsent(key, ()=>[]).add(s);\n  }\n  return map.values.toList();\n}",
        "hints": "Sort chars to form grouping key."
    },
    {
        "id": "dart-h-10",
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Hard",
        "language": "dart",
        "description": "Evaluate an RPN expression using a stack.",
        "examples": "[\"2\",\"1\",\"+\",\"3\",\"*\"] → 9",
        "solution": "int evalRPN(List<String> tokens) {\n  List<int> stack = [];\n  for (var t in tokens) {\n    if (int.tryParse(t) != null) {\n      stack.add(int.parse(t));\n    } else {\n      int b = stack.removeLast();\n      int a = stack.removeLast();\n      switch (t) {\n        case '+': stack.add(a + b); break;\n        case '-': stack.add(a - b); break;\n        case '*': stack.add(a * b); break;\n        case '/': stack.add(a ~/ b); break;\n      }\n    }\n  }\n  return stack.last;\n}",
        "hints": "Pop two values, apply operator."
    }
]