[
    {
        "id": "go-h-1",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Hard",
        "language": "go",
        "description": "Given a string s, return the length of the longest substring without repeating characters using sliding window.",
        "examples": "\"abcabcbb\" → 3",
        "solution": "package main\nimport \"fmt\"\nfunc lengthOfLongestSubstring(s string) int {\n    seen := map[byte]bool{}\n    left, maxLen := 0, 0\n    for right := 0; right < len(s); right++ {\n        for seen[s[right]] {\n            delete(seen, s[left])\n            left++\n        }\n        seen[s[right]] = true\n        if right-left+1 > maxLen {\n            maxLen = right-left+1\n        }\n    }\n    return maxLen\n}",
        "hints": "Use sliding window + hashmap."
    },
    {
        "id": "go-h-2",
        "title": "Word Break (Dynamic Programming)",
        "difficulty": "Hard",
        "language": "go",
        "description": "Return true if string s can be segmented into dictionary words.",
        "examples": "\"leetcode\", [\"leet\",\"code\"] → true",
        "solution": "package main\nimport \"fmt\"\nfunc wordBreak(s string, dict []string) bool {\n    set := map[string]bool{}\n    for _, w := range dict { set[w] = true }\n    dp := make([]bool, len(s)+1)\n    dp[0] = true\n    for i := 1; i <= len(s); i++ {\n        for j := 0; j < i; j++ {\n            if dp[j] && set[s[j:i]] {\n                dp[i] = true\n                break\n            }\n        }\n    }\n    return dp[len(s)]\n}",
        "hints": "dp[i] = true if substring 0..i forms words."
    },
    {
        "id": "go-h-3",
        "title": "Binary Tree Level Order Traversal",
        "difficulty": "Hard",
        "language": "go",
        "description": "Perform BFS level-order traversal of a binary tree.",
        "examples": "[3,9,20,null,null,15,7] → [[3],[9,20],[15,7]]",
        "solution": "type TreeNode struct{\n    Val int\n    Left *TreeNode\n    Right *TreeNode\n}\nfunc levelOrder(root *TreeNode) [][]int {\n    if root == nil { return [][]int{} }\n    res := [][]int{}\n    queue := []*TreeNode{root}\n    for len(queue) > 0 {\n        size := len(queue)\n        level := []int{}\n        for i := 0; i < size; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            level = append(level, node.Val)\n            if node.Left != nil { queue = append(queue, node.Left) }\n            if node.Right != nil { queue = append(queue, node.Right) }\n        }\n        res = append(res, level)\n    }\n    return res\n}",
        "hints": "Use queue BFS."
    },
    {
        "id": "go-h-4",
        "title": "Combination Sum",
        "difficulty": "Hard",
        "language": "go",
        "description": "Return all unique combinations where the candidate numbers sum to target.",
        "examples": "[2,3,6,7], target=7 → [[2,2,3],[7]]",
        "solution": "func combinationSum(c []int, target int) [][]int {\n    res := [][]int{}\n    var backtrack func(start int, remain int, path []int)\n    backtrack = func(start int, remain int, path []int) {\n        if remain == 0 {\n            tmp := make([]int, len(path))\n            copy(tmp, path)\n            res = append(res, tmp)\n            return\n        }\n        if remain < 0 { return }\n        for i := start; i < len(c); i++ {\n            backtrack(i, remain-c[i], append(path, c[i]))\n        }\n    }\n    backtrack(0, target, []int{})\n    return res\n}",
        "hints": "Use backtracking recursion."
    },
    {
        "id": "go-h-5",
        "title": "Merge Intervals",
        "difficulty": "Hard",
        "language": "go",
        "description": "Merge all overlapping intervals.",
        "examples": "[[1,3],[2,6],[8,10]] → [[1,6],[8,10]]",
        "solution": "import \"sort\"\nfunc merge(intervals [][]int) [][]int {\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n    res := [][]int{}\n    cur := intervals[0]\n    for _, next := range intervals[1:] {\n        if next[0] <= cur[1] {\n            if next[1] > cur[1] { cur[1] = next[1] }\n        } else {\n            res = append(res, cur)\n            cur = next\n        }\n    }\n    res = append(res, cur)\n    return res\n}",
        "hints": "Sort intervals first."
    },
    {
        "id": "go-h-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Hard",
        "language": "go",
        "description": "Return k most frequent elements in an integer slice.",
        "examples": "[1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "import \"sort\"\nfunc topK(nums []int, k int) []int {\n    freq := map[int]int{}\n    for _, n := range nums { freq[n]++ }\n    arr := make([][2]int, 0)\n    for key, val := range freq { arr = append(arr, [2]int{key, val}) }\n    sort.Slice(arr, func(i,j int) bool { return arr[i][1] > arr[j][1] })\n    res := []int{}\n    for i := 0; i < k; i++ { res = append(res, arr[i][0]) }\n    return res\n}",
        "hints": "Sort by frequency descending."
    },
    {
        "id": "go-h-7",
        "title": "Longest Increasing Subsequence (Binary Search DP)",
        "difficulty": "Hard",
        "language": "go",
        "description": "Return the length of LIS using O(n log n) DP.",
        "examples": "[10,9,2,5,3,7,101,18] → 4",
        "solution": "import \"sort\"\nfunc lengthOfLIS(nums []int) int {\n    dp := []int{}\n    for _, n := range nums {\n        idx := sort.SearchInts(dp, n)\n        if idx == len(dp) {\n            dp = append(dp, n)\n        } else {\n            dp[idx] = n\n        }\n    }\n    return len(dp)\n}",
        "hints": "Use patience sorting method."
    },
    {
        "id": "go-h-8",
        "title": "Number of Islands",
        "difficulty": "Hard",
        "language": "go",
        "description": "Count the number of islands in a 2D grid using DFS.",
        "examples": "[[1,1,0],[0,1,0]] → 1",
        "solution": "func numIslands(grid [][]byte) int {\n    rows, cols := len(grid), len(grid[0])\n    var dfs func(r,c int)\n    dfs = func(r,c int) {\n        if r<0 || c<0 || r>=rows || c>=cols || grid[r][c]=='0' { return }\n        grid[r][c] = '0'\n        dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1)\n    }\n    count := 0\n    for r := 0; r < rows; r++ {\n        for c := 0; c < cols; c++ {\n            if grid[r][c] == '1' {\n                count++\n                dfs(r,c)\n            }\n        }\n    }\n    return count\n}",
        "hints": "DFS flood-fill."
    },
    {
        "id": "go-h-9",
        "title": "Group Anagrams",
        "difficulty": "Hard",
        "language": "go",
        "description": "Group strings that are anagrams of each other.",
        "examples": "[\"eat\",\"tea\",\"ate\"] → [[\"eat\",\"tea\",\"ate\"]]",
        "solution": "import \"sort\"\nfunc groupAnagrams(strs []string) [][]string {\n    m := map[string][]string{}\n    for _, s := range strs {\n        chars := []rune(s)\n        sort.Slice(chars, func(i,j int) bool { return chars[i] < chars[j] })\n        key := string(chars)\n        m[key] = append(m[key], s)\n    }\n    res := [][]string{}\n    for _, v := range m { res = append(res, v) }\n    return res\n}",
        "hints": "Sort characters to form key."
    },
    {
        "id": "go-h-10",
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Hard",
        "language": "go",
        "description": "Evaluate the value of an arithmetic expression written in Reverse Polish Notation.",
        "examples": "[\"2\",\"1\",\"+\",\"3\",\"*\"] → 9",
        "solution": "import \"strconv\"\nfunc evalRPN(tokens []string) int {\n    stack := []int{}\n    for _, t := range tokens {\n        if v, err := strconv.Atoi(t); err == nil {\n            stack = append(stack, v)\n        } else {\n            b := stack[len(stack)-1]\n            a := stack[len(stack)-2]\n            stack = stack[:len(stack)-2]\n            switch t {\n                case \"+\": stack = append(stack, a+b)\n                case \"-\": stack = append(stack, a-b)\n                case \"*\": stack = append(stack, a*b)\n                case \"/\": stack = append(stack, a/b)\n            }\n        }\n    }\n    return stack[len(stack)-1]\n}",
        "hints": "Use stack of ints."
    }
]