[
    {
        "id": "ts-e-1",
        "title": "Two Sum",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. Use a hash map for O(n) time.",
        "examples": "Input: nums=[2,7,11,15], target=9\nOutput: [0,1]",
        "solution": "function twoSum(nums: number[], target: number): number[] {\n  const map = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const diff = target - nums[i];\n    if (map.has(diff)) return [map.get(diff)!, i];\n    map.set(nums[i], i);\n  }\n  return [];\n}",
        "hints": "Check if complement exists before adding current number."
    },
    {
        "id": "ts-e-2",
        "title": "Reverse String",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Reverse a character array in place using the two-pointer technique.",
        "examples": "Input: ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']",
        "solution": "function reverseString(s: string[]): void {\n  let l = 0, r = s.length - 1;\n  while (l < r) {\n    [s[l], s[r]] = [s[r], s[l]];\n    l++; r--;\n  }\n}",
        "hints": "Use array destructuring to swap."
    },
    {
        "id": "ts-e-3",
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Determine if strings s and t are anagrams of each other using frequency counting.",
        "examples": "Input: s='anagram', t='nagaram'\nOutput: true",
        "solution": "function isAnagram(s: string, t: string): boolean {\n  if (s.length !== t.length) return false;\n  const count = Array(26).fill(0);\n  for (let i = 0; i < s.length; i++) {\n    count[s.charCodeAt(i) - 97]++;\n    count[t.charCodeAt(i) - 97]--;\n  }\n  return count.every(x => x === 0);\n}",
        "hints": "Use ASCII difference to map letters to indices."
    },
    {
        "id": "ts-e-4",
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Given an integer array nums, return true if any value appears at least twice.",
        "examples": "Input: [1,2,3,1]\nOutput: true",
        "solution": "function containsDuplicate(nums: number[]): boolean {\n  const set = new Set<number>();\n  for (const n of nums) {\n    if (set.has(n)) return true;\n    set.add(n);\n  }\n  return false;\n}",
        "hints": "Set provides O(1) membership check."
    },
    {
        "id": "ts-e-5",
        "title": "Maximum Subarray",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Find the contiguous subarray with the largest sum using Kadane's algorithm.",
        "examples": "Input: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6",
        "solution": "function maxSubArray(nums: number[]): number {\n  let maxSum = nums[0];\n  let current = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    current = Math.max(nums[i], current + nums[i]);\n    maxSum = Math.max(maxSum, current);\n  }\n  return maxSum;\n}",
        "hints": "Reset running sum if it becomes negative."
    },
    {
        "id": "ts-e-6",
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Merge two sorted linked lists into one sorted list.",
        "examples": "Input: [1,2,4], [1,3,4]\nOutput: [1,1,2,3,4,4]",
        "solution": "class ListNode {\n  val: number;\n  next: ListNode | null = null;\n  constructor(val?: number) { this.val = val ?? 0; }\n}\nfunction mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  const dummy = new ListNode(0);\n  let cur = dummy;\n  while (l1 && l2) {\n    if (l1.val < l2.val) {\n      cur.next = l1;\n      l1 = l1.next;\n    } else {\n      cur.next = l2;\n      l2 = l2.next;\n    }\n    cur = cur.next;\n  }\n  cur.next = l1 || l2;\n  return dummy.next;\n}",
        "hints": "Use dummy node to simplify pointer logic."
    },
    {
        "id": "ts-e-7",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Find max profit from one buy-sell transaction.",
        "examples": "Input: [7,1,5,3,6,4]\nOutput: 5",
        "solution": "function maxProfit(prices: number[]): number {\n  let minP = Infinity, profit = 0;\n  for (const p of prices) {\n    minP = Math.min(minP, p);\n    profit = Math.max(profit, p - minP);\n  }\n  return profit;\n}",
        "hints": "Track minimum price seen so far."
    },
    {
        "id": "ts-e-8",
        "title": "Single Number",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Find the element that appears once while all others appear twice.",
        "examples": "Input: [2,2,1]\nOutput: 1",
        "solution": "function singleNumber(nums: number[]): number {\n  return nums.reduce((a, b) => a ^ b);\n}",
        "hints": "XOR cancels duplicates."
    },
    {
        "id": "ts-e-9",
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Compute intersection of two arrays including duplicates.",
        "examples": "Input: [1,2,2,1], [2,2]\nOutput: [2,2]",
        "solution": "function intersect(nums1: number[], nums2: number[]): number[] {\n  const map = new Map<number, number>();\n  for (let n of nums1) map.set(n, (map.get(n) || 0) + 1);\n  const res: number[] = [];\n  for (let n of nums2) {\n    const count = map.get(n) || 0;\n    if (count > 0) {\n      res.push(n);\n      map.set(n, count - 1);\n    }\n  }\n  return res;\n}",
        "hints": "Frequency map for nums1."
    },
    {
        "id": "ts-e-10",
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "language": "typescript",
        "description": "Check if parentheses are valid using a stack.",
        "examples": "Input: \"()[]{}\"\nOutput: true",
        "solution": "function isValid(s: string): boolean {\n  const stack: string[] = [];\n  const map: Record<string,string> = {')':'(',']':'[','}':'{'};\n  for (let c of s) {\n    if (c in map) {\n      if (stack.pop() !== map[c]) return false;\n    } else stack.push(c);\n  }\n  return stack.length === 0;\n}",
        "hints": "Match closing bracket with last opened bracket."
    }
]