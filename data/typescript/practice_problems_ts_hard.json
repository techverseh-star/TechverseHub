[
    {
        "id": "ts-h-1",
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "You are given an array of k sorted linked lists. Merge all lists into one sorted list and return it. Use a min-heap for efficiency.",
        "examples": "Input: [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
        "solution": "class ListNode {\n  val: number;\n  next: ListNode | null = null;\n  constructor(val: number) { this.val = val; }\n}\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n  const pq = new MinPriorityQueue<ListNode>({ priority: x => x.val });\n  for (let node of lists) if (node) pq.enqueue(node);\n  const dummy = new ListNode(0);\n  let cur = dummy;\n  while (!pq.isEmpty()) {\n    const node = pq.dequeue().element;\n    cur.next = node;\n    cur = cur.next;\n    if (node.next) pq.enqueue(node.next);\n  }\n  return dummy.next;\n}",
        "hints": "Push first node of each list into min-heap and pop smallest repeatedly."
    },
    {
        "id": "ts-h-2",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Compute how much water can be trapped after rainfall using two-pointer technique.",
        "examples": "Input: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6",
        "solution": "function trap(height: number[]): number {\n  let l=0, r=height.length-1;\n  let leftMax=0, rightMax=0, ans=0;\n  while (l < r) {\n    if (height[l] < height[r]) {\n      if (height[l] >= leftMax) leftMax = height[l];\n      else ans += leftMax - height[l];\n      l++;\n    } else {\n      if (height[r] >= rightMax) rightMax = height[r];\n      else ans += rightMax - height[r];\n      r--;\n    }\n  }\n  return ans;\n}",
        "hints": "Move pointer from the shorter side inward."
    },
    {
        "id": "ts-h-3",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Find the smallest substring of s that contains all characters of t using sliding window and frequency tracking.",
        "examples": "s = \"ADOBECODEBANC\", t = \"ABC\" → \"BANC\"",
        "solution": "function minWindow(s: string, t: string): string {\n  const need = new Map<string, number>();\n  for (let c of t) need.set(c, (need.get(c)||0) + 1);\n  let have = 0, needCount = need.size;\n  const window = new Map<string, number>();\n  let res: [number, number] = [0, Infinity];\n  let l = 0;\n  for (let r = 0; r < s.length; r++) {\n    const c = s[r];\n    window.set(c, (window.get(c)||0)+1);\n    if (need.has(c) && window.get(c) === need.get(c)) have++;\n    while (have === needCount) {\n      if (r - l + 1 < res[1] - res[0]) res = [l, r];\n      const lc = s[l];\n      window.set(lc, window.get(lc)! - 1);\n      if (need.has(lc) && window.get(lc)! < need.get(lc)!) have--;\n      l++;\n    }\n  }\n  return res[1] === Infinity ? \"\" : s.slice(res[0], res[1]+1);\n}",
        "hints": "Expand window until valid, shrink until invalid."
    },
    {
        "id": "ts-h-4",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Find shortest transformation from beginWord to endWord by changing 1 letter at a time. Use BFS on wildcard buckets.",
        "examples": "hit → cog, words=[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] → 5",
        "solution": "function ladderLength(begin: string, end: string, list: string[]): number {\n  const dict = new Set(list);\n  if (!dict.has(end)) return 0;\n  const L = begin.length;\n  const buckets = new Map<string, string[]>();\n  for (let w of dict) {\n    for (let i=0;i<L;i++){\n      const key = w.slice(0,i)+'*'+w.slice(i+1);\n      (buckets.get(key) || buckets.set(key, []).get(key))!.push(w);\n    }\n  }\n  const q: [string, number][] = [[begin,1]];\n  const seen = new Set([begin]);\n  while (q.length) {\n    const [word, step] = q.shift()!;\n    if (word === end) return step;\n    for (let i=0;i<L;i++){\n      const key = word.slice(0,i)+'*'+word.slice(i+1);\n      for (let nxt of buckets.get(key)||[]) {\n        if (!seen.has(nxt)) {\n          seen.add(nxt);\n          q.push([nxt, step+1]);\n        }\n      }\n    }\n  }\n  return 0;\n}",
        "hints": "Wildcard adjacency significantly reduces graph size."
    },
    {
        "id": "ts-h-5",
        "title": "N-Queens",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Place N queens on a chessboard so that none attack each other. Return all possible solutions.",
        "examples": "n = 4 → 2 solutions",
        "solution": "function solveNQueens(n: number): string[][] {\n  const res: string[][] = [];\n  const board = Array.from({length:n},()=>Array(n).fill('.'));\n  const col = new Set<number>(), posDiag = new Set<number>(), negDiag = new Set<number>();\n  function backtrack(r: number) {\n    if (r === n) {\n      res.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let c=0;c<n;c++){\n      if (col.has(c) || posDiag.has(r+c) || negDiag.has(r-c)) continue;\n      col.add(c); posDiag.add(r+c); negDiag.add(r-c);\n      board[r][c] = 'Q';\n      backtrack(r+1);\n      board[r][c] = '.';\n      col.delete(c); posDiag.delete(r+c); negDiag.delete(r-c);\n    }\n  }\n  backtrack(0);\n  return res;\n}",
        "hints": "Track diagonals using r+c and r-c."
    },
    {
        "id": "ts-h-6",
        "title": "Serialize & Deserialize Binary Tree",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Implement serialize() and deserialize() using BFS and null placeholders.",
        "examples": "Input: [1,2,3,null,null,4,5]",
        "solution": "class TreeNode {\n  val: number;\n  left: TreeNode | null = null;\n  right: TreeNode | null = null;\n  constructor(val: number){ this.val = val; }\n}\nfunction serialize(root: TreeNode | null): string {\n  if (!root) return '#';\n  const q = [root];\n  const out: (number|string)[] = [];\n  while (q.length) {\n    const n = q.shift()!;\n    if (!n) { out.push('#'); continue; }\n    out.push(n.val);\n    q.push(n.left, n.right);\n  }\n  return out.join(',');\n}\nfunction deserialize(data: string): TreeNode | null {\n  if (data === '#') return null;\n  const vals = data.split(',');\n  const root = new TreeNode(+vals[0]);\n  const q = [root];\n  let i=1;\n  while (q.length && i < vals.length) {\n    const n = q.shift()!;\n    if (vals[i] !== '#') { n.left = new TreeNode(+vals[i]); q.push(n.left); }\n    i++;\n    if (vals[i] !== '#') { n.right = new TreeNode(+vals[i]); q.push(n.right); }\n    i++;\n  }\n  return root;\n}",
        "hints": "Use queue for level-order traversal."
    },
    {
        "id": "ts-h-7",
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Compute longest valid parentheses substring using stack technique.",
        "examples": "Input: \"(()\"\nOutput: 2",
        "solution": "function longestValidParentheses(s: string): number {\n  let max = 0;\n  const stack = [-1];\n  for (let i=0;i<s.length;i++){\n    if (s[i] === '(') stack.push(i);\n    else {\n      stack.pop();\n      if (!stack.length) stack.push(i);\n      else max = Math.max(max, i - stack[stack.length-1]);\n    }\n  }\n  return max;\n}",
        "hints": "Base index trick handles unmatched parentheses."
    },
    {
        "id": "ts-h-8",
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Maximize coins by choosing optimal burst order using interval DP.",
        "examples": "Input: [3,1,5,8] → 167",
        "solution": "function maxCoins(nums: number[]): number {\n  nums = [1, ...nums, 1];\n  const n = nums.length;\n  const dp = Array.from({length:n},()=>Array(n).fill(0));\n  for (let len=2; len<n; len++){\n    for (let l=0; l+len<n; l++){\n      const r = l+len;\n      for (let k=l+1; k<r; k++){\n        dp[l][r] = Math.max(dp[l][r], nums[l]*nums[k]*nums[r] + dp[l][k] + dp[k][r]);\n      }\n    }\n  }\n  return dp[0][n-1];\n}",
        "hints": "Try each balloon as the last burst in interval."
    },
    {
        "id": "ts-h-9",
        "title": "Alien Dictionary",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Given sorted alien dictionary words, find valid character ordering using topological sort.",
        "examples": "Input: [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"] → \"wertf\"",
        "solution": "function alienOrder(words: string[]): string {\n  const graph = new Map<string, string[]>();\n  const indeg = new Map<string, number>();\n  for (let w of words) for (let c of w) { graph.set(c, []); indeg.set(c, 0); }\n  for (let i=0;i<words.length-1;i++){\n    const w1 = words[i], w2 = words[i+1];\n    if (w1.startsWith(w2) && w1.length > w2.length) return '';\n    for (let j=0;j<Math.min(w1.length,w2.length);j++){\n      if (w1[j] !== w2[j]){\n        graph.get(w1[j])!.push(w2[j]);\n        indeg.set(w2[j], indeg.get(w2[j])!+1);\n        break;\n      }\n    }\n  }\n  const q = [...indeg].filter(([c,d]) => d===0).map(([c])=>c);\n  const out: string[] = [];\n  while (q.length){\n    const c = q.shift()!;\n    out.push(c);\n    for (let nxt of graph.get(c)!) {\n      indeg.set(nxt, indeg.get(nxt)! -1);\n      if (indeg.get(nxt) === 0) q.push(nxt);\n    }\n  }\n  return out.length === indeg.size ? out.join('') : '';\n}",
        "hints": "Edges come from mismatched characters in adjacent words."
    },
    {
        "id": "ts-h-10",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "language": "typescript",
        "description": "Implement regex '.' and '*' matching using dynamic programming over pattern and string.",
        "examples": "Input: s=\"aab\", p=\"c*a*b\" → true",
        "solution": "function isMatch(s: string, p: string): boolean {\n  const dp = Array.from({length:s.length+1},()=>Array(p.length+1).fill(false));\n  dp[0][0] = true;\n  for (let j=2;j<=p.length;j++) if (p[j-1] === '*') dp[0][j] = dp[0][j-2];\n  for (let i=1;i<=s.length;i++){\n    for (let j=1;j<=p.length;j++){\n      if (p[j-1] === '.' || p[j-1] === s[i-1]) dp[i][j] = dp[i-1][j-1];\n      else if (p[j-1] === '*'){\n        dp[i][j] = dp[i][j-2];\n        if (p[j-2] === '.' || p[j-2] === s[i-1]) dp[i][j] ||= dp[i-1][j];\n      }\n    }\n  }\n  return dp[s.length][p.length];\n}",
        "hints": "dp[i][j] covers 0 or many matches of preceding char."
    }
]