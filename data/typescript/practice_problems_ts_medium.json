[
    {
        "id": "ts-m-1",
        "title": "Add Two Numbers (Linked List)",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Two non-negative integers are represented by two linked lists in reverse order. Add them and return the sum as a linked list.",
        "examples": "Input: l1=[2,4,3], l2=[5,6,4]\nOutput: [7,0,8]",
        "solution": "class ListNode {\n  val: number;\n  next: ListNode | null = null;\n  constructor(val: number) { this.val = val; }\n}\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  const dummy = new ListNode(0);\n  let cur = dummy;\n  let carry = 0;\n  while (l1 || l2) {\n    const x = l1 ? l1.val : 0;\n    const y = l2 ? l2.val : 0;\n    const sum = x + y + carry;\n    carry = Math.floor(sum / 10);\n    cur.next = new ListNode(sum % 10);\n    cur = cur.next;\n    if (l1) l1 = l1.next;\n    if (l2) l2 = l2.next;\n  }\n  if (carry) cur.next = new ListNode(carry);\n  return dummy.next;\n}",
        "hints": "Use dummy head node and carry tracking."
    },
    {
        "id": "ts-m-2",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Return the length of the longest substring without repeating characters using sliding window.",
        "examples": "Input: \"abcabcbb\" → 3",
        "solution": "function lengthOfLongestSubstring(s: string): number {\n  let map = new Map<string, number>();\n  let left = 0, maxLen = 0;\n  for (let right = 0; right < s.length; right++) {\n    if (map.has(s[right])) left = Math.max(left, map.get(s[right])! + 1);\n    map.set(s[right], right);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}",
        "hints": "Move left pointer to ensure substring contains no duplicates."
    },
    {
        "id": "ts-m-3",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Search for target in rotated sorted array using binary search partitioning logic.",
        "examples": "Input: nums=[4,5,6,7,0,1,2], target=0 → 4",
        "solution": "function search(nums: number[], target: number): number {\n  let l = 0, r = nums.length - 1;\n  while (l <= r) {\n    const m = Math.floor((l + r) / 2);\n    if (nums[m] === target) return m;\n    if (nums[l] <= nums[m]) {\n      if (nums[l] <= target && target < nums[m]) r = m - 1;\n      else l = m + 1;\n    } else {\n      if (nums[m] < target && target <= nums[r]) l = m + 1;\n      else r = m - 1;\n    }\n  }\n  return -1;\n}",
        "hints": "Identify sorted half and move search accordingly."
    },
    {
        "id": "ts-m-4",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Find two lines that form the container with maximum water capacity.",
        "examples": "Input: [1,8,6,2,5,4,8,3,7] → 49",
        "solution": "function maxArea(height: number[]): number {\n  let l = 0, r = height.length - 1;\n  let ans = 0;\n  while (l < r) {\n    const h = Math.min(height[l], height[r]);\n    ans = Math.max(ans, h * (r - l));\n    if (height[l] < height[r]) l++;\n    else r--;\n  }\n  return ans;\n}",
        "hints": "Move pointer from shorter side inward."
    },
    {
        "id": "ts-m-5",
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Return kth largest element in array. Sorting solution provided.",
        "examples": "Input: nums=[3,2,1,5,6,4], k=2 → 5",
        "solution": "function findKthLargest(nums: number[], k: number): number {\n  nums.sort((a,b)=>b-a);\n  return nums[k-1];\n}",
        "hints": "Sorting is simplest; heaps useful for optimization."
    },
    {
        "id": "ts-m-6",
        "title": "Top K Frequent Elements",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Find k most frequent numbers using bucket sort.",
        "examples": "Input: nums=[1,1,1,2,2,3], k=2 → [1,2]",
        "solution": "function topKFrequent(nums: number[], k: number): number[] {\n  const freq = new Map<number, number>();\n  for (const n of nums) freq.set(n, (freq.get(n)||0)+1);\n  const buckets: number[][] = Array.from({length:nums.length+1},()=>[]);\n  for (const [n,c] of freq) buckets[c].push(n);\n  const res: number[] = [];\n  for (let i=buckets.length-1; i>=0 && res.length<k; i--) {\n    for (const n of buckets[i]) {\n      res.push(n);\n      if (res.length===k) break;\n    }\n  }\n  return res;\n}",
        "hints": "Bucket size = frequency count."
    },
    {
        "id": "ts-m-7",
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Return array output[i] = product of all nums except nums[i] without using division.",
        "examples": "Input: [1,2,3,4] → [24,12,8,6]",
        "solution": "function productExceptSelf(nums: number[]): number[] {\n  const n = nums.length;\n  const out = Array(n).fill(1);\n  for (let i=1; i<n; i++) out[i] = out[i-1] * nums[i-1];\n  let suf = 1;\n  for (let i=n-1; i>=0; i--) {\n    out[i] *= suf;\n    suf *= nums[i];\n  }\n  return out;\n}",
        "hints": "Left prefix × right suffix."
    },
    {
        "id": "ts-m-8",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Count number of islands ('1's connected horizontally or vertically).",
        "examples": "Grid → 3 islands",
        "solution": "function numIslands(grid: string[][]): number {\n  const m=grid.length, n=grid[0].length;\n  let count=0;\n  const dfs=(i:number,j:number)=>{\n    if(i<0||j<0||i>=m||j>=n||grid[i][j]==='0') return;\n    grid[i][j]='0';\n    dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1);\n  };\n  for(let i=0;i<m;i++) for(let j=0;j<n;j++)\n    if(grid[i][j]==='1'){ count++; dfs(i,j); }\n  return count;\n}",
        "hints": "DFS flood fill."
    },
    {
        "id": "ts-m-9",
        "title": "Coin Change",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Given coins and amount, compute minimum coins using DP.",
        "examples": "coins=[1,2,5], amount=11 → 3",
        "solution": "function coinChange(coins: number[], amount: number): number {\n  const dp = Array(amount+1).fill(Infinity);\n  dp[0]=0;\n  for(const c of coins)\n    for(let i=c;i<=amount;i++) dp[i] = Math.min(dp[i], dp[i-c]+1);\n  return dp[amount]===Infinity ? -1 : dp[amount];\n}",
        "hints": "Unbounded knapsack DP."
    },
    {
        "id": "ts-m-10",
        "title": "Word Break",
        "difficulty": "Medium",
        "language": "typescript",
        "description": "Determine if s can be segmented into words of dictionary.",
        "examples": "Input: s=\"leetcode\", dict=[\"leet\",\"code\"] → true",
        "solution": "function wordBreak(s: string, dict: string[]): boolean {\n  const set=new Set(dict);\n  const dp=Array(s.length+1).fill(false);\n  dp[0]=true;\n  for(let i=1;i<=s.length;i++){\n    for(let j=0;j<i;j++){\n      if(dp[j] && set.has(s.substring(j,i))){ dp[i]=true; break; }\n    }\n  }\n  return dp[s.length];\n}",
        "hints": "dp[i] = true if any j<i gives a valid word segment."
    }
]