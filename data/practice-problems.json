[
  {"id": "py-e-1", "title": "Two Sum", "difficulty": "Easy", "language": "python", "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.", "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: nums[0] + nums[1] = 2 + 7 = 9", "solution": "def solution(nums, target):\n    seen = {}\n    for i, n in enumerate(nums):\n        if target - n in seen:\n            return [seen[target - n], i]\n        seen[n] = i\n    return []", "hints": "Use a hash map to store numbers you've seen. For each number, check if its complement exists."},
  {"id": "py-e-2", "title": "Reverse String", "difficulty": "Easy", "language": "python", "description": "Write a function that reverses a string. The input string is given as an array of characters.", "examples": "Input: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']", "solution": "def solution(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s", "hints": "Use two pointers from both ends and swap characters."},
  {"id": "py-e-3", "title": "Palindrome Check", "difficulty": "Easy", "language": "python", "description": "Check if a given string is a palindrome, considering only alphanumeric characters.", "examples": "Input: s = 'A man, a plan, a canal: Panama'\nOutput: true", "solution": "def solution(s):\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]", "hints": "Clean the string first, then compare with its reverse."},
  {"id": "py-e-4", "title": "FizzBuzz", "difficulty": "Easy", "language": "python", "description": "Return a list where for multiples of 3 print 'Fizz', multiples of 5 print 'Buzz', both print 'FizzBuzz'.", "examples": "Input: n = 15\nOutput: ['1','2','Fizz','4','Buzz','Fizz','7','8','Fizz','Buzz','11','Fizz','13','14','FizzBuzz']", "solution": "def solution(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(str(i))\n    return result", "hints": "Check divisibility by 15 first (both 3 and 5)."},
  {"id": "py-e-5", "title": "Find Maximum", "difficulty": "Easy", "language": "python", "description": "Find the maximum element in an array of integers.", "examples": "Input: nums = [1, 5, 3, 9, 2]\nOutput: 9", "solution": "def solution(nums):\n    if not nums:\n        return None\n    max_val = nums[0]\n    for n in nums:\n        if n > max_val:\n            max_val = n\n    return max_val", "hints": "Iterate through the array and keep track of the maximum."},
  {"id": "py-e-6", "title": "Count Vowels", "difficulty": "Easy", "language": "python", "description": "Count the number of vowels in a given string.", "examples": "Input: s = 'hello world'\nOutput: 3", "solution": "def solution(s):\n    vowels = 'aeiouAEIOU'\n    return sum(1 for c in s if c in vowels)", "hints": "Define a set of vowels and count matches."},
  {"id": "py-e-7", "title": "Remove Duplicates", "difficulty": "Easy", "language": "python", "description": "Remove duplicates from a sorted array in-place and return the new length.", "examples": "Input: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]", "solution": "def solution(nums):\n    if not nums:\n        return 0\n    k = 1\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            nums[k] = nums[i]\n            k += 1\n    return k", "hints": "Use two pointers - one for reading, one for writing."},
  {"id": "py-e-8", "title": "Sum of List", "difficulty": "Easy", "language": "python", "description": "Calculate the sum of all elements in a list.", "examples": "Input: nums = [1, 2, 3, 4, 5]\nOutput: 15", "solution": "def solution(nums):\n    total = 0\n    for n in nums:\n        total += n\n    return total", "hints": "Iterate and accumulate the sum."},
  {"id": "py-e-9", "title": "Factorial", "difficulty": "Easy", "language": "python", "description": "Calculate the factorial of a non-negative integer.", "examples": "Input: n = 5\nOutput: 120", "solution": "def solution(n):\n    if n <= 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result", "hints": "Multiply all integers from 1 to n."},
  {"id": "py-e-10", "title": "Prime Check", "difficulty": "Easy", "language": "python", "description": "Check if a number is prime.", "examples": "Input: n = 17\nOutput: true", "solution": "def solution(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "hints": "Check divisibility up to square root of n."},
  {"id": "py-m-1", "title": "Longest Substring", "difficulty": "Medium", "language": "python", "description": "Find the length of the longest substring without repeating characters.", "examples": "Input: s = 'abcabcbb'\nOutput: 3\nExplanation: 'abc' is the longest.", "solution": "def solution(s):\n    seen = {}\n    start = max_len = 0\n    for i, c in enumerate(s):\n        if c in seen and seen[c] >= start:\n            start = seen[c] + 1\n        seen[c] = i\n        max_len = max(max_len, i - start + 1)\n    return max_len", "hints": "Use sliding window with a hash map to track character positions."},
  {"id": "py-m-2", "title": "Valid Parentheses", "difficulty": "Medium", "language": "python", "description": "Determine if the input string has valid parentheses.", "examples": "Input: s = '()[]{}'\nOutput: true", "solution": "def solution(s):\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    for c in s:\n        if c in pairs:\n            stack.append(c)\n        elif not stack or pairs[stack.pop()] != c:\n            return False\n    return len(stack) == 0", "hints": "Use a stack to match opening and closing brackets."},
  {"id": "py-m-3", "title": "Merge Intervals", "difficulty": "Medium", "language": "python", "description": "Merge all overlapping intervals.", "examples": "Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]", "solution": "def solution(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    for interval in intervals:\n        if merged and interval[0] <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged", "hints": "Sort by start time, then merge overlapping intervals."},
  {"id": "py-m-4", "title": "Binary Search", "difficulty": "Medium", "language": "python", "description": "Implement binary search to find target in a sorted array.", "examples": "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4", "solution": "def solution(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "hints": "Divide the search space in half each iteration."},
  {"id": "py-m-5", "title": "Group Anagrams", "difficulty": "Medium", "language": "python", "description": "Group strings that are anagrams of each other.", "examples": "Input: strs = ['eat','tea','tan','ate','nat','bat']\nOutput: [['eat','tea','ate'],['tan','nat'],['bat']]", "solution": "def solution(strs):\n    from collections import defaultdict\n    groups = defaultdict(list)\n    for s in strs:\n        key = ''.join(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())", "hints": "Use sorted string as key for grouping."},
  {"id": "py-m-6", "title": "Product of Array", "difficulty": "Medium", "language": "python", "description": "Return an array where each element is the product of all other elements.", "examples": "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]", "solution": "def solution(nums):\n    n = len(nums)\n    result = [1] * n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n    suffix = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n    return result", "hints": "Calculate prefix and suffix products separately."},
  {"id": "py-m-7", "title": "Rotate Array", "difficulty": "Medium", "language": "python", "description": "Rotate the array to the right by k steps.", "examples": "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]", "solution": "def solution(nums, k):\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums", "hints": "Use slicing or reverse three times."},
  {"id": "py-m-8", "title": "Spiral Matrix", "difficulty": "Medium", "language": "python", "description": "Return all elements of the matrix in spiral order.", "examples": "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]", "solution": "def solution(matrix):\n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    return result", "hints": "Process layer by layer from outside to inside."},
  {"id": "py-m-9", "title": "Word Search", "difficulty": "Medium", "language": "python", "description": "Determine if word exists in the grid.", "examples": "Input: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'\nOutput: true", "solution": "def solution(board, word):\n    def dfs(i, j, k):\n        if k == len(word): return True\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return False\n        if board[i][j] != word[k]: return False\n        tmp, board[i][j] = board[i][j], '#'\n        found = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n        board[i][j] = tmp\n        return found\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if dfs(i, j, 0): return True\n    return False", "hints": "Use DFS with backtracking."},
  {"id": "py-m-10", "title": "Subsets", "difficulty": "Medium", "language": "python", "description": "Generate all possible subsets of a set.", "examples": "Input: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]", "solution": "def solution(nums):\n    result = [[]]\n    for num in nums:\n        result += [subset + [num] for subset in result]\n    return result", "hints": "For each element, add it to all existing subsets."},
  {"id": "py-h-1", "title": "Merge K Lists", "difficulty": "Hard", "language": "python", "description": "Merge k sorted linked lists into one sorted list.", "examples": "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]", "solution": "import heapq\ndef solution(lists):\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    result = []\n    while heap:\n        val, i, j = heapq.heappop(heap)\n        result.append(val)\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j+1], i, j+1))\n    return result", "hints": "Use a min-heap to efficiently get the smallest element."},
  {"id": "py-h-2", "title": "Trapping Rain Water", "difficulty": "Hard", "language": "python", "description": "Calculate how much water can be trapped after raining.", "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6", "solution": "def solution(height):\n    left, right = 0, len(height) - 1\n    left_max = right_max = water = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water", "hints": "Use two pointers from both ends."},
  {"id": "py-h-3", "title": "N-Queens", "difficulty": "Hard", "language": "python", "description": "Place n queens on an nÃ—n chessboard so no two queens attack each other.", "examples": "Input: n = 4\nOutput: 2", "solution": "def solution(n):\n    def backtrack(row, cols, diag1, diag2):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if col in cols or row-col in diag1 or row+col in diag2:\n                continue\n            count += backtrack(row+1, cols|{col}, diag1|{row-col}, diag2|{row+col})\n        return count\n    return backtrack(0, set(), set(), set())", "hints": "Use backtracking with sets to track attacked positions."},
  {"id": "py-h-4", "title": "Word Break II", "difficulty": "Hard", "language": "python", "description": "Return all possible sentences by segmenting string into dictionary words.", "examples": "Input: s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']\nOutput: ['cats and dog','cat sand dog']", "solution": "def solution(s, wordDict):\n    wordSet = set(wordDict)\n    memo = {}\n    def dfs(start):\n        if start in memo:\n            return memo[start]\n        if start == len(s):\n            return ['']\n        result = []\n        for end in range(start + 1, len(s) + 1):\n            word = s[start:end]\n            if word in wordSet:\n                for sub in dfs(end):\n                    result.append(word + (' ' + sub if sub else ''))\n        memo[start] = result\n        return result\n    return dfs(0)", "hints": "Use DFS with memoization."},
  {"id": "py-h-5", "title": "Median of Arrays", "difficulty": "Hard", "language": "python", "description": "Find the median of two sorted arrays.", "examples": "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.0", "solution": "def solution(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    while left <= right:\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        left1 = nums1[i-1] if i > 0 else float('-inf')\n        right1 = nums1[i] if i < m else float('inf')\n        left2 = nums2[j-1] if j > 0 else float('-inf')\n        right2 = nums2[j] if j < n else float('inf')\n        if left1 <= right2 and left2 <= right1:\n            if (m + n) % 2:\n                return max(left1, left2)\n            return (max(left1, left2) + min(right1, right2)) / 2\n        elif left1 > right2:\n            right = i - 1\n        else:\n            left = i + 1", "hints": "Binary search on the smaller array."},
  {"id": "py-h-6", "title": "Edit Distance", "difficulty": "Hard", "language": "python", "description": "Find the minimum number of operations to convert word1 to word2.", "examples": "Input: word1 = 'horse', word2 = 'ros'\nOutput: 3", "solution": "def solution(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]", "hints": "Use dynamic programming with a 2D table."},
  {"id": "py-h-7", "title": "Regular Expression", "difficulty": "Hard", "language": "python", "description": "Implement regular expression matching with '.' and '*'.", "examples": "Input: s = 'aa', p = 'a*'\nOutput: true", "solution": "def solution(s, p):\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for j in range(2, n + 1):\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-2]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j-1] == '*':\n                dp[i][j] = dp[i][j-2]\n                if p[j-2] == '.' or p[j-2] == s[i-1]:\n                    dp[i][j] = dp[i][j] or dp[i-1][j]\n            elif p[j-1] == '.' or p[j-1] == s[i-1]:\n                dp[i][j] = dp[i-1][j-1]\n    return dp[m][n]", "hints": "Use dynamic programming considering * matches zero or more."},
  {"id": "py-h-8", "title": "Longest Path", "difficulty": "Hard", "language": "python", "description": "Find the longest increasing path in a matrix.", "examples": "Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4", "solution": "def solution(matrix):\n    if not matrix: return 0\n    m, n = len(matrix), len(matrix[0])\n    memo = {}\n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        val = matrix[i][j]\n        result = 1\n        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > val:\n                result = max(result, 1 + dfs(ni, nj))\n        memo[(i, j)] = result\n        return result\n    return max(dfs(i, j) for i in range(m) for j in range(n))", "hints": "DFS with memoization from each cell."},
  {"id": "py-h-9", "title": "Serialize Tree", "difficulty": "Hard", "language": "python", "description": "Serialize and deserialize a binary tree.", "examples": "Input: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]", "solution": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = self.right = None\n\ndef serialize(root):\n    if not root: return 'null'\n    return f'{root.val},{serialize(root.left)},{serialize(root.right)}'\n\ndef deserialize(data):\n    vals = iter(data.split(','))\n    def build():\n        val = next(vals)\n        if val == 'null': return None\n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    return build()", "hints": "Use preorder traversal for serialization."},
  {"id": "py-h-10", "title": "LRU Cache", "difficulty": "Hard", "language": "python", "description": "Implement an LRU (Least Recently Used) cache.", "examples": "Input: capacity = 2, operations = ['put(1,1)','put(2,2)','get(1)','put(3,3)','get(2)']\nOutput: [null,null,1,null,-1]", "solution": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)", "hints": "Use OrderedDict or doubly linked list with hash map."},

  {"id": "js-e-1", "title": "Two Sum", "difficulty": "Easy", "language": "javascript", "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.", "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]", "solution": "function solution(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}", "hints": "Use a hash map to store seen numbers and their indices."},
  {"id": "js-e-2", "title": "Reverse String", "difficulty": "Easy", "language": "javascript", "description": "Reverse a string in place.", "examples": "Input: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']", "solution": "function solution(s) {\n  let left = 0, right = s.length - 1;\n  while (left < right) {\n    [s[left], s[right]] = [s[right], s[left]];\n    left++;\n    right--;\n  }\n  return s;\n}", "hints": "Use two pointers from both ends."},
  {"id": "js-e-3", "title": "Palindrome Check", "difficulty": "Easy", "language": "javascript", "description": "Check if a string is a palindrome.", "examples": "Input: s = 'racecar'\nOutput: true", "solution": "function solution(s) {\n  const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return cleaned === cleaned.split('').reverse().join('');\n}", "hints": "Clean the string and compare with its reverse."},
  {"id": "js-e-4", "title": "FizzBuzz", "difficulty": "Easy", "language": "javascript", "description": "Classic FizzBuzz problem.", "examples": "Input: n = 5\nOutput: ['1','2','Fizz','4','Buzz']", "solution": "function solution(n) {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 15 === 0) result.push('FizzBuzz');\n    else if (i % 3 === 0) result.push('Fizz');\n    else if (i % 5 === 0) result.push('Buzz');\n    else result.push(String(i));\n  }\n  return result;\n}", "hints": "Check divisibility by 15 first."},
  {"id": "js-e-5", "title": "Maximum Subarray", "difficulty": "Easy", "language": "javascript", "description": "Find the contiguous subarray with the largest sum.", "examples": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6", "solution": "function solution(nums) {\n  let maxSum = nums[0], currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}", "hints": "Use Kadane's algorithm."},
  {"id": "js-e-6", "title": "Valid Anagram", "difficulty": "Easy", "language": "javascript", "description": "Check if two strings are anagrams.", "examples": "Input: s = 'anagram', t = 'nagaram'\nOutput: true", "solution": "function solution(s, t) {\n  if (s.length !== t.length) return false;\n  const count = {};\n  for (const c of s) count[c] = (count[c] || 0) + 1;\n  for (const c of t) {\n    if (!count[c]) return false;\n    count[c]--;\n  }\n  return true;\n}", "hints": "Count character frequencies."},
  {"id": "js-e-7", "title": "Merge Arrays", "difficulty": "Easy", "language": "javascript", "description": "Merge two sorted arrays.", "examples": "Input: nums1 = [1,2,3], nums2 = [2,5,6]\nOutput: [1,2,2,3,5,6]", "solution": "function solution(nums1, nums2) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < nums1.length && j < nums2.length) {\n    if (nums1[i] <= nums2[j]) result.push(nums1[i++]);\n    else result.push(nums2[j++]);\n  }\n  while (i < nums1.length) result.push(nums1[i++]);\n  while (j < nums2.length) result.push(nums2[j++]);\n  return result;\n}", "hints": "Use two pointers technique."},
  {"id": "js-e-8", "title": "Buy Sell Stock", "difficulty": "Easy", "language": "javascript", "description": "Find maximum profit from buying and selling stock.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 5", "solution": "function solution(prices) {\n  let minPrice = Infinity, maxProfit = 0;\n  for (const price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n  return maxProfit;\n}", "hints": "Track minimum price and maximum profit."},
  {"id": "js-e-9", "title": "Single Number", "difficulty": "Easy", "language": "javascript", "description": "Find the number that appears only once.", "examples": "Input: nums = [2,2,1]\nOutput: 1", "solution": "function solution(nums) {\n  let result = 0;\n  for (const n of nums) {\n    result ^= n;\n  }\n  return result;\n}", "hints": "XOR all numbers - pairs cancel out."},
  {"id": "js-e-10", "title": "Contains Duplicate", "difficulty": "Easy", "language": "javascript", "description": "Check if array contains any duplicates.", "examples": "Input: nums = [1,2,3,1]\nOutput: true", "solution": "function solution(nums) {\n  return new Set(nums).size !== nums.length;\n}", "hints": "Use a Set to check for duplicates."},
  {"id": "js-m-1", "title": "Container With Water", "difficulty": "Medium", "language": "javascript", "description": "Find two lines that together with x-axis forms a container with the most water.", "examples": "Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49", "solution": "function solution(height) {\n  let left = 0, right = height.length - 1, maxArea = 0;\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    maxArea = Math.max(maxArea, area);\n    if (height[left] < height[right]) left++;\n    else right--;\n  }\n  return maxArea;\n}", "hints": "Use two pointers moving inward."},
  {"id": "js-m-2", "title": "3Sum", "difficulty": "Medium", "language": "javascript", "description": "Find all unique triplets that sum to zero.", "examples": "Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]", "solution": "function solution(nums) {\n  nums.sort((a, b) => a - b);\n  const result = [];\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    let left = i + 1, right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) left++;\n      else right--;\n    }\n  }\n  return result;\n}", "hints": "Sort and use two pointers for each fixed element."},
  {"id": "js-m-3", "title": "Longest Palindrome", "difficulty": "Medium", "language": "javascript", "description": "Find the longest palindromic substring.", "examples": "Input: s = 'babad'\nOutput: 'bab'", "solution": "function solution(s) {\n  let start = 0, maxLen = 1;\n  function expandFromCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      if (right - left + 1 > maxLen) {\n        start = left;\n        maxLen = right - left + 1;\n      }\n      left--;\n      right++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    expandFromCenter(i, i);\n    expandFromCenter(i, i + 1);\n  }\n  return s.substring(start, start + maxLen);\n}", "hints": "Expand around center for both odd and even length palindromes."},
  {"id": "js-m-4", "title": "Permutations", "difficulty": "Medium", "language": "javascript", "description": "Generate all permutations of an array.", "examples": "Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "solution": "function solution(nums) {\n  const result = [];\n  function backtrack(path, remaining) {\n    if (remaining.length === 0) {\n      result.push([...path]);\n      return;\n    }\n    for (let i = 0; i < remaining.length; i++) {\n      path.push(remaining[i]);\n      backtrack(path, [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\n      path.pop();\n    }\n  }\n  backtrack([], nums);\n  return result;\n}", "hints": "Use backtracking to build permutations."},
  {"id": "js-m-5", "title": "Search Rotated", "difficulty": "Medium", "language": "javascript", "description": "Search in a rotated sorted array.", "examples": "Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4", "solution": "function solution(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) right = mid - 1;\n      else left = mid + 1;\n    } else {\n      if (target > nums[mid] && target <= nums[right]) left = mid + 1;\n      else right = mid - 1;\n    }\n  }\n  return -1;\n}", "hints": "Modified binary search - determine which half is sorted."},
  {"id": "js-m-6", "title": "Coin Change", "difficulty": "Medium", "language": "javascript", "description": "Find minimum coins needed to make an amount.", "examples": "Input: coins = [1,2,5], amount = 11\nOutput: 3", "solution": "function solution(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}", "hints": "Use dynamic programming."},
  {"id": "js-m-7", "title": "Jump Game", "difficulty": "Medium", "language": "javascript", "description": "Determine if you can reach the last index.", "examples": "Input: nums = [2,3,1,1,4]\nOutput: true", "solution": "function solution(nums) {\n  let maxReach = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;\n    maxReach = Math.max(maxReach, i + nums[i]);\n  }\n  return true;\n}", "hints": "Track the maximum reachable index."},
  {"id": "js-m-8", "title": "Unique Paths", "difficulty": "Medium", "language": "javascript", "description": "Count unique paths from top-left to bottom-right in a grid.", "examples": "Input: m = 3, n = 7\nOutput: 28", "solution": "function solution(m, n) {\n  const dp = Array(m).fill(null).map(() => Array(n).fill(1));\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n    }\n  }\n  return dp[m - 1][n - 1];\n}", "hints": "Each cell is sum of paths from top and left."},
  {"id": "js-m-9", "title": "Decode Ways", "difficulty": "Medium", "language": "javascript", "description": "Count ways to decode a digit string to letters.", "examples": "Input: s = '226'\nOutput: 3", "solution": "function solution(s) {\n  if (s[0] === '0') return 0;\n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1;\n  dp[1] = 1;\n  for (let i = 2; i <= n; i++) {\n    if (s[i - 1] !== '0') dp[i] += dp[i - 1];\n    const two = parseInt(s.substring(i - 2, i));\n    if (two >= 10 && two <= 26) dp[i] += dp[i - 2];\n  }\n  return dp[n];\n}", "hints": "Use DP considering single and double digit decodings."},
  {"id": "js-m-10", "title": "House Robber", "difficulty": "Medium", "language": "javascript", "description": "Find maximum amount you can rob without robbing adjacent houses.", "examples": "Input: nums = [1,2,3,1]\nOutput: 4", "solution": "function solution(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  let prev2 = 0, prev1 = 0;\n  for (const num of nums) {\n    const current = Math.max(prev1, prev2 + num);\n    prev2 = prev1;\n    prev1 = current;\n  }\n  return prev1;\n}", "hints": "DP: either rob current + skip previous, or skip current."},
  {"id": "js-h-1", "title": "Merge K Lists", "difficulty": "Hard", "language": "javascript", "description": "Merge k sorted linked lists.", "examples": "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]", "solution": "function solution(lists) {\n  const result = [];\n  const flat = lists.flat().sort((a, b) => a - b);\n  return flat;\n}", "hints": "Flatten and sort, or use a min-heap."},
  {"id": "js-h-2", "title": "Trapping Rain Water", "difficulty": "Hard", "language": "javascript", "description": "Calculate trapped rain water.", "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6", "solution": "function solution(height) {\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0, water = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n      left++;\n    } else {\n      height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n      right--;\n    }\n  }\n  return water;\n}", "hints": "Use two pointers from both ends."},
  {"id": "js-h-3", "title": "Word Ladder", "difficulty": "Hard", "language": "javascript", "description": "Find shortest transformation sequence length.", "examples": "Input: beginWord = 'hit', endWord = 'cog', wordList = ['hot','dot','dog','lot','log','cog']\nOutput: 5", "solution": "function solution(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n  const queue = [[beginWord, 1]];\n  while (queue.length > 0) {\n    const [word, length] = queue.shift();\n    if (word === endWord) return length;\n    for (let i = 0; i < word.length; i++) {\n      for (let c = 97; c <= 122; c++) {\n        const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1);\n        if (wordSet.has(newWord)) {\n          queue.push([newWord, length + 1]);\n          wordSet.delete(newWord);\n        }\n      }\n    }\n  }\n  return 0;\n}", "hints": "BFS to find shortest path."},
  {"id": "js-h-4", "title": "Sliding Window Max", "difficulty": "Hard", "language": "javascript", "description": "Return max sliding window.", "examples": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]", "solution": "function solution(nums, k) {\n  const result = [];\n  const deque = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {\n      deque.pop();\n    }\n    deque.push(i);\n    if (deque[0] === i - k) deque.shift();\n    if (i >= k - 1) result.push(nums[deque[0]]);\n  }\n  return result;\n}", "hints": "Use monotonic deque."},
  {"id": "js-h-5", "title": "Serialize Tree", "difficulty": "Hard", "language": "javascript", "description": "Serialize and deserialize binary tree.", "examples": "Input: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]", "solution": "function serialize(root) {\n  if (!root) return 'null';\n  return `${root.val},${serialize(root.left)},${serialize(root.right)}`;\n}\n\nfunction deserialize(data) {\n  const vals = data.split(',');\n  let i = 0;\n  function build() {\n    if (vals[i] === 'null') { i++; return null; }\n    const node = { val: parseInt(vals[i++]), left: null, right: null };\n    node.left = build();\n    node.right = build();\n    return node;\n  }\n  return build();\n}", "hints": "Use preorder traversal."},
  {"id": "js-h-6", "title": "LRU Cache", "difficulty": "Hard", "language": "javascript", "description": "Implement LRU cache.", "examples": "LRUCache cache = new LRUCache(2);\ncache.put(1, 1);\ncache.get(1); // returns 1", "solution": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n  put(key, value) {\n    if (this.cache.has(key)) this.cache.delete(key);\n    this.cache.set(key, value);\n    if (this.cache.size > this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n  }\n}", "hints": "Use Map which maintains insertion order."},
  {"id": "js-h-7", "title": "Median Data Stream", "difficulty": "Hard", "language": "javascript", "description": "Find median from data stream.", "examples": "addNum(1), addNum(2), findMedian() -> 1.5, addNum(3), findMedian() -> 2.0", "solution": "class MedianFinder {\n  constructor() {\n    this.nums = [];\n  }\n  addNum(num) {\n    let left = 0, right = this.nums.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.nums[mid] < num) left = mid + 1;\n      else right = mid;\n    }\n    this.nums.splice(left, 0, num);\n  }\n  findMedian() {\n    const n = this.nums.length;\n    if (n % 2 === 1) return this.nums[Math.floor(n / 2)];\n    return (this.nums[n / 2 - 1] + this.nums[n / 2]) / 2;\n  }\n}", "hints": "Maintain sorted array or use two heaps."},
  {"id": "js-h-8", "title": "Regular Expression", "difficulty": "Hard", "language": "javascript", "description": "Implement regex matching with . and *.", "examples": "Input: s = 'aa', p = 'a*'\nOutput: true", "solution": "function solution(s, p) {\n  const m = s.length, n = p.length;\n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(false));\n  dp[0][0] = true;\n  for (let j = 2; j <= n; j++) {\n    if (p[j - 1] === '*') dp[0][j] = dp[0][j - 2];\n  }\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '*') {\n        dp[i][j] = dp[i][j - 2];\n        if (p[j - 2] === '.' || p[j - 2] === s[i - 1]) {\n          dp[i][j] = dp[i][j] || dp[i - 1][j];\n        }\n      } else if (p[j - 1] === '.' || p[j - 1] === s[i - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      }\n    }\n  }\n  return dp[m][n];\n}", "hints": "Use DP considering * matches zero or more."},
  {"id": "js-h-9", "title": "Longest Valid Parens", "difficulty": "Hard", "language": "javascript", "description": "Find length of longest valid parentheses substring.", "examples": "Input: s = '(()'\nOutput: 2", "solution": "function solution(s) {\n  const stack = [-1];\n  let maxLen = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      stack.push(i);\n    } else {\n      stack.pop();\n      if (stack.length === 0) {\n        stack.push(i);\n      } else {\n        maxLen = Math.max(maxLen, i - stack[stack.length - 1]);\n      }\n    }\n  }\n  return maxLen;\n}", "hints": "Use stack to track indices."},
  {"id": "js-h-10", "title": "First Missing Positive", "difficulty": "Hard", "language": "javascript", "description": "Find the smallest missing positive integer.", "examples": "Input: nums = [3,4,-1,1]\nOutput: 2", "solution": "function solution(nums) {\n  const n = nums.length;\n  for (let i = 0; i < n; i++) {\n    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n      [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i + 1) return i + 1;\n  }\n  return n + 1;\n}", "hints": "Place each number in its correct position."},

  {"id": "ts-e-1", "title": "Two Sum", "difficulty": "Easy", "language": "typescript", "description": "Given an array of integers nums and an integer target, return indices of the two numbers that add up to target.", "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]", "solution": "function solution(nums: number[], target: number): number[] {\n  const map = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement)!, i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}", "hints": "Use a Map with proper type annotations."},
  {"id": "ts-e-2", "title": "Reverse String", "difficulty": "Easy", "language": "typescript", "description": "Reverse a string in place with type safety.", "examples": "Input: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']", "solution": "function solution(s: string[]): string[] {\n  let left = 0, right = s.length - 1;\n  while (left < right) {\n    [s[left], s[right]] = [s[right], s[left]];\n    left++;\n    right--;\n  }\n  return s;\n}", "hints": "Use typed array parameter."},
  {"id": "ts-e-3", "title": "Valid Anagram", "difficulty": "Easy", "language": "typescript", "description": "Check if two strings are anagrams with TypeScript.", "examples": "Input: s = 'anagram', t = 'nagaram'\nOutput: true", "solution": "function solution(s: string, t: string): boolean {\n  if (s.length !== t.length) return false;\n  const count: Record<string, number> = {};\n  for (const c of s) count[c] = (count[c] || 0) + 1;\n  for (const c of t) {\n    if (!count[c]) return false;\n    count[c]--;\n  }\n  return true;\n}", "hints": "Use Record type for character counting."},
  {"id": "ts-e-4", "title": "Contains Duplicate", "difficulty": "Easy", "language": "typescript", "description": "Check if array contains duplicates.", "examples": "Input: nums = [1,2,3,1]\nOutput: true", "solution": "function solution(nums: number[]): boolean {\n  return new Set(nums).size !== nums.length;\n}", "hints": "Set automatically removes duplicates."},
  {"id": "ts-e-5", "title": "Maximum Subarray", "difficulty": "Easy", "language": "typescript", "description": "Find the contiguous subarray with the largest sum.", "examples": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6", "solution": "function solution(nums: number[]): number {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}", "hints": "Kadane's algorithm with proper typing."},
  {"id": "ts-e-6", "title": "Merge Arrays", "difficulty": "Easy", "language": "typescript", "description": "Merge two sorted arrays.", "examples": "Input: nums1 = [1,2,3], nums2 = [2,5,6]\nOutput: [1,2,2,3,5,6]", "solution": "function solution(nums1: number[], nums2: number[]): number[] {\n  const result: number[] = [];\n  let i = 0, j = 0;\n  while (i < nums1.length && j < nums2.length) {\n    if (nums1[i] <= nums2[j]) result.push(nums1[i++]);\n    else result.push(nums2[j++]);\n  }\n  return [...result, ...nums1.slice(i), ...nums2.slice(j)];\n}", "hints": "Two pointer merge with spread operator."},
  {"id": "ts-e-7", "title": "Roman to Int", "difficulty": "Easy", "language": "typescript", "description": "Convert Roman numeral to integer.", "examples": "Input: s = 'III'\nOutput: 3", "solution": "function solution(s: string): number {\n  const map: Record<string, number> = {\n    'I': 1, 'V': 5, 'X': 10, 'L': 50,\n    'C': 100, 'D': 500, 'M': 1000\n  };\n  let result = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (i + 1 < s.length && map[s[i]] < map[s[i + 1]]) {\n      result -= map[s[i]];\n    } else {\n      result += map[s[i]];\n    }\n  }\n  return result;\n}", "hints": "Use Record type for roman numeral mapping."},
  {"id": "ts-e-8", "title": "Climbing Stairs", "difficulty": "Easy", "language": "typescript", "description": "Count ways to climb n stairs.", "examples": "Input: n = 3\nOutput: 3", "solution": "function solution(n: number): number {\n  if (n <= 2) return n;\n  let prev1 = 2, prev2 = 1;\n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n  return prev1;\n}", "hints": "Fibonacci sequence pattern."},
  {"id": "ts-e-9", "title": "Best Stock", "difficulty": "Easy", "language": "typescript", "description": "Best time to buy and sell stock.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 5", "solution": "function solution(prices: number[]): number {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  for (const price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n  return maxProfit;\n}", "hints": "Track minimum price and maximum profit."},
  {"id": "ts-e-10", "title": "Valid Parens", "difficulty": "Easy", "language": "typescript", "description": "Check balanced parentheses.", "examples": "Input: s = '()[]{}'\nOutput: true", "solution": "function solution(s: string): boolean {\n  const stack: string[] = [];\n  const pairs: Record<string, string> = {'(': ')', '[': ']', '{': '}'};\n  for (const c of s) {\n    if (c in pairs) stack.push(c);\n    else if (stack.length === 0 || pairs[stack.pop()!] !== c) return false;\n  }\n  return stack.length === 0;\n}", "hints": "Use stack with proper typing."},

  {"id": "java-e-1", "title": "Two Sum", "difficulty": "Easy", "language": "java", "description": "Find two numbers that add up to target.", "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]", "solution": "public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] {map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    return new int[] {};\n}", "hints": "Use HashMap for O(n) solution."},
  {"id": "java-e-2", "title": "Reverse String", "difficulty": "Easy", "language": "java", "description": "Reverse a character array in place.", "examples": "Input: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']", "solution": "public void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left] = s[right];\n        s[right] = temp;\n        left++;\n        right--;\n    }\n}", "hints": "Two pointer swap."},
  {"id": "java-e-3", "title": "Palindrome Number", "difficulty": "Easy", "language": "java", "description": "Check if an integer is a palindrome.", "examples": "Input: x = 121\nOutput: true", "solution": "public boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}", "hints": "Reverse the number and compare."},
  {"id": "java-e-4", "title": "Valid Anagram", "difficulty": "Easy", "language": "java", "description": "Check if two strings are anagrams.", "examples": "Input: s = 'anagram', t = 'nagaram'\nOutput: true", "solution": "public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) return false;\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        count[s.charAt(i) - 'a']++;\n        count[t.charAt(i) - 'a']--;\n    }\n    for (int c : count) {\n        if (c != 0) return false;\n    }\n    return true;\n}", "hints": "Use int array for character counting."},
  {"id": "java-e-5", "title": "Merge Lists", "difficulty": "Easy", "language": "java", "description": "Merge two sorted lists.", "examples": "Input: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]", "solution": "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n    while (l1 != null && l2 != null) {\n        if (l1.val <= l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    current.next = l1 != null ? l1 : l2;\n    return dummy.next;\n}", "hints": "Use dummy head for easier handling."},
  {"id": "java-e-6", "title": "Climbing Stairs", "difficulty": "Easy", "language": "java", "description": "Count ways to climb n stairs.", "examples": "Input: n = 3\nOutput: 3", "solution": "public int climbStairs(int n) {\n    if (n <= 2) return n;\n    int prev1 = 2, prev2 = 1;\n    for (int i = 3; i <= n; i++) {\n        int current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    return prev1;\n}", "hints": "Fibonacci sequence."},
  {"id": "java-e-7", "title": "Same Tree", "difficulty": "Easy", "language": "java", "description": "Check if two trees are the same.", "examples": "Input: p = [1,2,3], q = [1,2,3]\nOutput: true", "solution": "public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}", "hints": "Recursive comparison."},
  {"id": "java-e-8", "title": "Symmetric Tree", "difficulty": "Easy", "language": "java", "description": "Check if tree is symmetric.", "examples": "Input: root = [1,2,2,3,4,4,3]\nOutput: true", "solution": "public boolean isSymmetric(TreeNode root) {\n    return isMirror(root, root);\n}\n\nprivate boolean isMirror(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\n}", "hints": "Compare left subtree with right subtree mirror."},
  {"id": "java-e-9", "title": "Max Depth Tree", "difficulty": "Easy", "language": "java", "description": "Find maximum depth of binary tree.", "examples": "Input: root = [3,9,20,null,null,15,7]\nOutput: 3", "solution": "public int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}", "hints": "Recursive depth calculation."},
  {"id": "java-e-10", "title": "Path Sum", "difficulty": "Easy", "language": "java", "description": "Check if path sum equals target.", "examples": "Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], target = 22\nOutput: true", "solution": "public boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n    if (root.left == null && root.right == null) {\n        return targetSum == root.val;\n    }\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}", "hints": "Subtract value as you traverse."},

  {"id": "c-e-1", "title": "Two Sum", "difficulty": "Easy", "language": "c", "description": "Find two numbers that add to target.", "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]", "solution": "int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    *returnSize = 2;\n    int* result = (int*)malloc(2 * sizeof(int));\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n        }\n    }\n    return result;\n}", "hints": "Use nested loops for O(n^2) solution."},
  {"id": "c-e-2", "title": "Reverse Array", "difficulty": "Easy", "language": "c", "description": "Reverse array in place using pointers.", "examples": "Input: arr = [1,2,3,4,5]\nOutput: [5,4,3,2,1]", "solution": "void reverseArray(int* arr, int size) {\n    int *left = arr, *right = arr + size - 1;\n    while (left < right) {\n        int temp = *left;\n        *left = *right;\n        *right = temp;\n        left++;\n        right--;\n    }\n}", "hints": "Use pointer arithmetic."},
  {"id": "c-e-3", "title": "String Length", "difficulty": "Easy", "language": "c", "description": "Implement strlen without library.", "examples": "Input: s = 'hello'\nOutput: 5", "solution": "int myStrlen(const char* s) {\n    int len = 0;\n    while (s[len] != '\\0') {\n        len++;\n    }\n    return len;\n}", "hints": "Count until null terminator."},
  {"id": "c-e-4", "title": "Swap Numbers", "difficulty": "Easy", "language": "c", "description": "Swap two numbers using pointers.", "examples": "Input: a = 5, b = 10\nOutput: a = 10, b = 5", "solution": "void swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}", "hints": "Dereference to swap values."},
  {"id": "c-e-5", "title": "Binary Search", "difficulty": "Easy", "language": "c", "description": "Implement binary search.", "examples": "Input: arr = [1,2,3,4,5], target = 3\nOutput: 2", "solution": "int binarySearch(int* arr, int size, int target) {\n    int left = 0, right = size - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}", "hints": "Divide search space in half."},
  {"id": "c-e-6", "title": "Palindrome Check", "difficulty": "Easy", "language": "c", "description": "Check if string is palindrome.", "examples": "Input: s = 'racecar'\nOutput: 1", "solution": "int isPalindrome(const char* s) {\n    int len = 0;\n    while (s[len]) len++;\n    for (int i = 0; i < len / 2; i++) {\n        if (s[i] != s[len - 1 - i]) return 0;\n    }\n    return 1;\n}", "hints": "Compare characters from both ends."},
  {"id": "c-e-7", "title": "Find Maximum", "difficulty": "Easy", "language": "c", "description": "Find max element in array.", "examples": "Input: arr = [1,5,3,9,2]\nOutput: 9", "solution": "int findMax(int* arr, int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n    return max;\n}", "hints": "Iterate and track maximum."},
  {"id": "c-e-8", "title": "Count Digits", "difficulty": "Easy", "language": "c", "description": "Count digits in a number.", "examples": "Input: n = 12345\nOutput: 5", "solution": "int countDigits(int n) {\n    if (n == 0) return 1;\n    int count = 0;\n    n = n < 0 ? -n : n;\n    while (n > 0) {\n        count++;\n        n /= 10;\n    }\n    return count;\n}", "hints": "Divide by 10 until zero."},
  {"id": "c-e-9", "title": "Factorial", "difficulty": "Easy", "language": "c", "description": "Calculate factorial iteratively.", "examples": "Input: n = 5\nOutput: 120", "solution": "long factorial(int n) {\n    long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}", "hints": "Multiply from 1 to n."},
  {"id": "c-e-10", "title": "Prime Check", "difficulty": "Easy", "language": "c", "description": "Check if number is prime.", "examples": "Input: n = 17\nOutput: 1", "solution": "int isPrime(int n) {\n    if (n < 2) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}", "hints": "Check divisibility up to sqrt(n)."},

  {"id": "cpp-e-1", "title": "Two Sum", "difficulty": "Easy", "language": "cpp", "description": "Find two numbers that add to target.", "examples": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]", "solution": "vector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.count(complement)) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}", "hints": "Use unordered_map for O(1) lookup."},
  {"id": "cpp-e-2", "title": "Reverse String", "difficulty": "Easy", "language": "cpp", "description": "Reverse string using STL.", "examples": "Input: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']", "solution": "void reverseString(vector<char>& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        swap(s[left++], s[right--]);\n    }\n}", "hints": "Use swap or std::reverse."},
  {"id": "cpp-e-3", "title": "Valid Anagram", "difficulty": "Easy", "language": "cpp", "description": "Check if two strings are anagrams.", "examples": "Input: s = 'anagram', t = 'nagaram'\nOutput: true", "solution": "bool isAnagram(string s, string t) {\n    if (s.length() != t.length()) return false;\n    array<int, 26> count{};\n    for (int i = 0; i < s.length(); i++) {\n        count[s[i] - 'a']++;\n        count[t[i] - 'a']--;\n    }\n    return all_of(count.begin(), count.end(), [](int c) { return c == 0; });\n}", "hints": "Use std::array for counting."},
  {"id": "cpp-e-4", "title": "Contains Duplicate", "difficulty": "Easy", "language": "cpp", "description": "Check for duplicates using set.", "examples": "Input: nums = [1,2,3,1]\nOutput: true", "solution": "bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> seen;\n    for (int n : nums) {\n        if (seen.count(n)) return true;\n        seen.insert(n);\n    }\n    return false;\n}", "hints": "Use unordered_set for O(1) lookup."},
  {"id": "cpp-e-5", "title": "Maximum Subarray", "difficulty": "Easy", "language": "cpp", "description": "Kadane's algorithm.", "examples": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6", "solution": "int maxSubArray(vector<int>& nums) {\n    int maxSum = nums[0], currentSum = nums[0];\n    for (int i = 1; i < nums.size(); i++) {\n        currentSum = max(nums[i], currentSum + nums[i]);\n        maxSum = max(maxSum, currentSum);\n    }\n    return maxSum;\n}", "hints": "Track current and maximum sum."},
  {"id": "cpp-e-6", "title": "Merge Arrays", "difficulty": "Easy", "language": "cpp", "description": "Merge two sorted vectors.", "examples": "Input: nums1 = [1,2,3], nums2 = [2,5,6]\nOutput: [1,2,2,3,5,6]", "solution": "vector<int> merge(vector<int>& nums1, vector<int>& nums2) {\n    vector<int> result;\n    int i = 0, j = 0;\n    while (i < nums1.size() && j < nums2.size()) {\n        if (nums1[i] <= nums2[j]) result.push_back(nums1[i++]);\n        else result.push_back(nums2[j++]);\n    }\n    while (i < nums1.size()) result.push_back(nums1[i++]);\n    while (j < nums2.size()) result.push_back(nums2[j++]);\n    return result;\n}", "hints": "Two pointer merge."},
  {"id": "cpp-e-7", "title": "Roman to Int", "difficulty": "Easy", "language": "cpp", "description": "Roman numeral to integer.", "examples": "Input: s = 'III'\nOutput: 3", "solution": "int romanToInt(string s) {\n    unordered_map<char, int> m = {\n        {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},\n        {'C', 100}, {'D', 500}, {'M', 1000}\n    };\n    int result = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i + 1 < s.length() && m[s[i]] < m[s[i + 1]])\n            result -= m[s[i]];\n        else\n            result += m[s[i]];\n    }\n    return result;\n}", "hints": "Subtract when smaller precedes larger."},
  {"id": "cpp-e-8", "title": "Climbing Stairs", "difficulty": "Easy", "language": "cpp", "description": "Ways to climb stairs (DP).", "examples": "Input: n = 3\nOutput: 3", "solution": "int climbStairs(int n) {\n    if (n <= 2) return n;\n    int prev1 = 2, prev2 = 1;\n    for (int i = 3; i <= n; i++) {\n        int current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    return prev1;\n}", "hints": "Fibonacci sequence."},
  {"id": "cpp-e-9", "title": "Best Stock", "difficulty": "Easy", "language": "cpp", "description": "Best time to buy/sell stock.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 5", "solution": "int maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX, maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}", "hints": "Track minimum price and maximum profit."},
  {"id": "cpp-e-10", "title": "Valid Parens", "difficulty": "Easy", "language": "cpp", "description": "Check balanced parentheses.", "examples": "Input: s = '()[]{}'\nOutput: true", "solution": "bool isValid(string s) {\n    stack<char> st;\n    unordered_map<char, char> pairs = {{')', '('}, {']', '['}, {'}', '{'}};\n    for (char c : s) {\n        if (pairs.count(c)) {\n            if (st.empty() || st.top() != pairs[c]) return false;\n            st.pop();\n        } else {\n            st.push(c);\n        }\n    }\n    return st.empty();\n}", "hints": "Use stack for matching."}
]
